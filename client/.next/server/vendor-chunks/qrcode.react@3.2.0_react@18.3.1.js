"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/qrcode.react@3.2.0_react@18.3.1";
exports.ids = ["vendor-chunks/qrcode.react@3.2.0_react@18.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/qrcode.react@3.2.0_react@18.3.1/node_modules/qrcode.react/lib/esm/index.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/qrcode.react@3.2.0_react@18.3.1/node_modules/qrcode.react/lib/esm/index.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QRCodeCanvas: () => (/* binding */ QRCodeCanvas),\n/* harmony export */   QRCodeSVG: () => (/* binding */ QRCodeSVG),\n/* harmony export */   \"default\": () => (/* binding */ QRCode)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.0.4_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __objRest = (source, exclude)=>{\n    var target = {};\n    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n    }\n    return target;\n};\n// src/index.tsx\n\n// src/third-party/qrcodegen/index.ts\n/**\n * @license QR Code generator library (TypeScript)\n * Copyright (c) Project Nayuki.\n * SPDX-License-Identifier: MIT\n */ var qrcodegen;\n((qrcodegen2)=>{\n    const _QrCode = class {\n        constructor(version, errorCorrectionLevel, dataCodewords, msk){\n            this.version = version;\n            this.errorCorrectionLevel = errorCorrectionLevel;\n            this.modules = [];\n            this.isFunction = [];\n            if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION) throw new RangeError(\"Version value out of range\");\n            if (msk < -1 || msk > 7) throw new RangeError(\"Mask value out of range\");\n            this.size = version * 4 + 17;\n            let row = [];\n            for(let i = 0; i < this.size; i++)row.push(false);\n            for(let i = 0; i < this.size; i++){\n                this.modules.push(row.slice());\n                this.isFunction.push(row.slice());\n            }\n            this.drawFunctionPatterns();\n            const allCodewords = this.addEccAndInterleave(dataCodewords);\n            this.drawCodewords(allCodewords);\n            if (msk == -1) {\n                let minPenalty = 1e9;\n                for(let i = 0; i < 8; i++){\n                    this.applyMask(i);\n                    this.drawFormatBits(i);\n                    const penalty = this.getPenaltyScore();\n                    if (penalty < minPenalty) {\n                        msk = i;\n                        minPenalty = penalty;\n                    }\n                    this.applyMask(i);\n                }\n            }\n            assert(0 <= msk && msk <= 7);\n            this.mask = msk;\n            this.applyMask(msk);\n            this.drawFormatBits(msk);\n            this.isFunction = [];\n        }\n        static encodeText(text, ecl) {\n            const segs = qrcodegen2.QrSegment.makeSegments(text);\n            return _QrCode.encodeSegments(segs, ecl);\n        }\n        static encodeBinary(data, ecl) {\n            const seg = qrcodegen2.QrSegment.makeBytes(data);\n            return _QrCode.encodeSegments([\n                seg\n            ], ecl);\n        }\n        static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {\n            if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError(\"Invalid value\");\n            let version;\n            let dataUsedBits;\n            for(version = minVersion;; version++){\n                const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;\n                const usedBits = QrSegment.getTotalBits(segs, version);\n                if (usedBits <= dataCapacityBits2) {\n                    dataUsedBits = usedBits;\n                    break;\n                }\n                if (version >= maxVersion) throw new RangeError(\"Data too long\");\n            }\n            for (const newEcl of [\n                _QrCode.Ecc.MEDIUM,\n                _QrCode.Ecc.QUARTILE,\n                _QrCode.Ecc.HIGH\n            ]){\n                if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n            }\n            let bb = [];\n            for (const seg of segs){\n                appendBits(seg.mode.modeBits, 4, bb);\n                appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n                for (const b of seg.getData())bb.push(b);\n            }\n            assert(bb.length == dataUsedBits);\n            const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;\n            assert(bb.length <= dataCapacityBits);\n            appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n            appendBits(0, (8 - bb.length % 8) % 8, bb);\n            assert(bb.length % 8 == 0);\n            for(let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)appendBits(padByte, 8, bb);\n            let dataCodewords = [];\n            while(dataCodewords.length * 8 < bb.length)dataCodewords.push(0);\n            bb.forEach((b, i)=>dataCodewords[i >>> 3] |= b << 7 - (i & 7));\n            return new _QrCode(version, ecl, dataCodewords, mask);\n        }\n        getModule(x, y) {\n            return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n        }\n        getModules() {\n            return this.modules;\n        }\n        drawFunctionPatterns() {\n            for(let i = 0; i < this.size; i++){\n                this.setFunctionModule(6, i, i % 2 == 0);\n                this.setFunctionModule(i, 6, i % 2 == 0);\n            }\n            this.drawFinderPattern(3, 3);\n            this.drawFinderPattern(this.size - 4, 3);\n            this.drawFinderPattern(3, this.size - 4);\n            const alignPatPos = this.getAlignmentPatternPositions();\n            const numAlign = alignPatPos.length;\n            for(let i = 0; i < numAlign; i++){\n                for(let j = 0; j < numAlign; j++){\n                    if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);\n                }\n            }\n            this.drawFormatBits(0);\n            this.drawVersion();\n        }\n        drawFormatBits(mask) {\n            const data = this.errorCorrectionLevel.formatBits << 3 | mask;\n            let rem = data;\n            for(let i = 0; i < 10; i++)rem = rem << 1 ^ (rem >>> 9) * 1335;\n            const bits = (data << 10 | rem) ^ 21522;\n            assert(bits >>> 15 == 0);\n            for(let i = 0; i <= 5; i++)this.setFunctionModule(8, i, getBit(bits, i));\n            this.setFunctionModule(8, 7, getBit(bits, 6));\n            this.setFunctionModule(8, 8, getBit(bits, 7));\n            this.setFunctionModule(7, 8, getBit(bits, 8));\n            for(let i = 9; i < 15; i++)this.setFunctionModule(14 - i, 8, getBit(bits, i));\n            for(let i = 0; i < 8; i++)this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));\n            for(let i = 8; i < 15; i++)this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));\n            this.setFunctionModule(8, this.size - 8, true);\n        }\n        drawVersion() {\n            if (this.version < 7) return;\n            let rem = this.version;\n            for(let i = 0; i < 12; i++)rem = rem << 1 ^ (rem >>> 11) * 7973;\n            const bits = this.version << 12 | rem;\n            assert(bits >>> 18 == 0);\n            for(let i = 0; i < 18; i++){\n                const color = getBit(bits, i);\n                const a = this.size - 11 + i % 3;\n                const b = Math.floor(i / 3);\n                this.setFunctionModule(a, b, color);\n                this.setFunctionModule(b, a, color);\n            }\n        }\n        drawFinderPattern(x, y) {\n            for(let dy = -4; dy <= 4; dy++){\n                for(let dx = -4; dx <= 4; dx++){\n                    const dist = Math.max(Math.abs(dx), Math.abs(dy));\n                    const xx = x + dx;\n                    const yy = y + dy;\n                    if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n                }\n            }\n        }\n        drawAlignmentPattern(x, y) {\n            for(let dy = -2; dy <= 2; dy++){\n                for(let dx = -2; dx <= 2; dx++)this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n            }\n        }\n        setFunctionModule(x, y, isDark) {\n            this.modules[y][x] = isDark;\n            this.isFunction[y][x] = true;\n        }\n        addEccAndInterleave(data) {\n            const ver = this.version;\n            const ecl = this.errorCorrectionLevel;\n            if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError(\"Invalid argument\");\n            const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n            const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n            const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);\n            const numShortBlocks = numBlocks - rawCodewords % numBlocks;\n            const shortBlockLen = Math.floor(rawCodewords / numBlocks);\n            let blocks = [];\n            const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);\n            for(let i = 0, k = 0; i < numBlocks; i++){\n                let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n                k += dat.length;\n                const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n                if (i < numShortBlocks) dat.push(0);\n                blocks.push(dat.concat(ecc));\n            }\n            let result = [];\n            for(let i = 0; i < blocks[0].length; i++){\n                blocks.forEach((block, j)=>{\n                    if (i != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[i]);\n                });\n            }\n            assert(result.length == rawCodewords);\n            return result;\n        }\n        drawCodewords(data) {\n            if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError(\"Invalid argument\");\n            let i = 0;\n            for(let right = this.size - 1; right >= 1; right -= 2){\n                if (right == 6) right = 5;\n                for(let vert = 0; vert < this.size; vert++){\n                    for(let j = 0; j < 2; j++){\n                        const x = right - j;\n                        const upward = (right + 1 & 2) == 0;\n                        const y = upward ? this.size - 1 - vert : vert;\n                        if (!this.isFunction[y][x] && i < data.length * 8) {\n                            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n                            i++;\n                        }\n                    }\n                }\n            }\n            assert(i == data.length * 8);\n        }\n        applyMask(mask) {\n            if (mask < 0 || mask > 7) throw new RangeError(\"Mask value out of range\");\n            for(let y = 0; y < this.size; y++){\n                for(let x = 0; x < this.size; x++){\n                    let invert;\n                    switch(mask){\n                        case 0:\n                            invert = (x + y) % 2 == 0;\n                            break;\n                        case 1:\n                            invert = y % 2 == 0;\n                            break;\n                        case 2:\n                            invert = x % 3 == 0;\n                            break;\n                        case 3:\n                            invert = (x + y) % 3 == 0;\n                            break;\n                        case 4:\n                            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n                            break;\n                        case 5:\n                            invert = x * y % 2 + x * y % 3 == 0;\n                            break;\n                        case 6:\n                            invert = (x * y % 2 + x * y % 3) % 2 == 0;\n                            break;\n                        case 7:\n                            invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n                            break;\n                        default:\n                            throw new Error(\"Unreachable\");\n                    }\n                    if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n                }\n            }\n        }\n        getPenaltyScore() {\n            let result = 0;\n            for(let y = 0; y < this.size; y++){\n                let runColor = false;\n                let runX = 0;\n                let runHistory = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                for(let x = 0; x < this.size; x++){\n                    if (this.modules[y][x] == runColor) {\n                        runX++;\n                        if (runX == 5) result += _QrCode.PENALTY_N1;\n                        else if (runX > 5) result++;\n                    } else {\n                        this.finderPenaltyAddHistory(runX, runHistory);\n                        if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n                        runColor = this.modules[y][x];\n                        runX = 1;\n                    }\n                }\n                result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;\n            }\n            for(let x = 0; x < this.size; x++){\n                let runColor = false;\n                let runY = 0;\n                let runHistory = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0\n                ];\n                for(let y = 0; y < this.size; y++){\n                    if (this.modules[y][x] == runColor) {\n                        runY++;\n                        if (runY == 5) result += _QrCode.PENALTY_N1;\n                        else if (runY > 5) result++;\n                    } else {\n                        this.finderPenaltyAddHistory(runY, runHistory);\n                        if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;\n                        runColor = this.modules[y][x];\n                        runY = 1;\n                    }\n                }\n                result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;\n            }\n            for(let y = 0; y < this.size - 1; y++){\n                for(let x = 0; x < this.size - 1; x++){\n                    const color = this.modules[y][x];\n                    if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1]) result += _QrCode.PENALTY_N2;\n                }\n            }\n            let dark = 0;\n            for (const row of this.modules)dark = row.reduce((sum, color)=>sum + (color ? 1 : 0), dark);\n            const total = this.size * this.size;\n            const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n            assert(0 <= k && k <= 9);\n            result += k * _QrCode.PENALTY_N4;\n            assert(0 <= result && result <= 2568888);\n            return result;\n        }\n        getAlignmentPatternPositions() {\n            if (this.version == 1) return [];\n            else {\n                const numAlign = Math.floor(this.version / 7) + 2;\n                const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n                let result = [\n                    6\n                ];\n                for(let pos = this.size - 7; result.length < numAlign; pos -= step)result.splice(1, 0, pos);\n                return result;\n            }\n        }\n        static getNumRawDataModules(ver) {\n            if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError(\"Version number out of range\");\n            let result = (16 * ver + 128) * ver + 64;\n            if (ver >= 2) {\n                const numAlign = Math.floor(ver / 7) + 2;\n                result -= (25 * numAlign - 10) * numAlign - 55;\n                if (ver >= 7) result -= 36;\n            }\n            assert(208 <= result && result <= 29648);\n            return result;\n        }\n        static getNumDataCodewords(ver, ecl) {\n            return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n        }\n        static reedSolomonComputeDivisor(degree) {\n            if (degree < 1 || degree > 255) throw new RangeError(\"Degree out of range\");\n            let result = [];\n            for(let i = 0; i < degree - 1; i++)result.push(0);\n            result.push(1);\n            let root = 1;\n            for(let i = 0; i < degree; i++){\n                for(let j = 0; j < result.length; j++){\n                    result[j] = _QrCode.reedSolomonMultiply(result[j], root);\n                    if (j + 1 < result.length) result[j] ^= result[j + 1];\n                }\n                root = _QrCode.reedSolomonMultiply(root, 2);\n            }\n            return result;\n        }\n        static reedSolomonComputeRemainder(data, divisor) {\n            let result = divisor.map((_)=>0);\n            for (const b of data){\n                const factor = b ^ result.shift();\n                result.push(0);\n                divisor.forEach((coef, i)=>result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));\n            }\n            return result;\n        }\n        static reedSolomonMultiply(x, y) {\n            if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError(\"Byte out of range\");\n            let z = 0;\n            for(let i = 7; i >= 0; i--){\n                z = z << 1 ^ (z >>> 7) * 285;\n                z ^= (y >>> i & 1) * x;\n            }\n            assert(z >>> 8 == 0);\n            return z;\n        }\n        finderPenaltyCountPatterns(runHistory) {\n            const n = runHistory[1];\n            assert(n <= this.size * 3);\n            const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n            return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n        }\n        finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {\n            if (currentRunColor) {\n                this.finderPenaltyAddHistory(currentRunLength, runHistory);\n                currentRunLength = 0;\n            }\n            currentRunLength += this.size;\n            this.finderPenaltyAddHistory(currentRunLength, runHistory);\n            return this.finderPenaltyCountPatterns(runHistory);\n        }\n        finderPenaltyAddHistory(currentRunLength, runHistory) {\n            if (runHistory[0] == 0) currentRunLength += this.size;\n            runHistory.pop();\n            runHistory.unshift(currentRunLength);\n        }\n    };\n    let QrCode = _QrCode;\n    QrCode.MIN_VERSION = 1;\n    QrCode.MAX_VERSION = 40;\n    QrCode.PENALTY_N1 = 3;\n    QrCode.PENALTY_N2 = 3;\n    QrCode.PENALTY_N3 = 40;\n    QrCode.PENALTY_N4 = 10;\n    QrCode.ECC_CODEWORDS_PER_BLOCK = [\n        [\n            -1,\n            7,\n            10,\n            15,\n            20,\n            26,\n            18,\n            20,\n            24,\n            30,\n            18,\n            20,\n            24,\n            26,\n            30,\n            22,\n            24,\n            28,\n            30,\n            28,\n            28,\n            28,\n            28,\n            30,\n            30,\n            26,\n            28,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ],\n        [\n            -1,\n            10,\n            16,\n            26,\n            18,\n            24,\n            16,\n            18,\n            22,\n            22,\n            26,\n            30,\n            22,\n            22,\n            24,\n            24,\n            28,\n            28,\n            26,\n            26,\n            26,\n            26,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28,\n            28\n        ],\n        [\n            -1,\n            13,\n            22,\n            18,\n            26,\n            18,\n            24,\n            18,\n            22,\n            20,\n            24,\n            28,\n            26,\n            24,\n            20,\n            30,\n            24,\n            28,\n            28,\n            26,\n            30,\n            28,\n            30,\n            30,\n            30,\n            30,\n            28,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ],\n        [\n            -1,\n            17,\n            28,\n            22,\n            16,\n            22,\n            28,\n            26,\n            26,\n            24,\n            28,\n            24,\n            28,\n            22,\n            24,\n            24,\n            30,\n            28,\n            28,\n            26,\n            28,\n            30,\n            24,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30,\n            30\n        ]\n    ];\n    QrCode.NUM_ERROR_CORRECTION_BLOCKS = [\n        [\n            -1,\n            1,\n            1,\n            1,\n            1,\n            1,\n            2,\n            2,\n            2,\n            2,\n            4,\n            4,\n            4,\n            4,\n            4,\n            6,\n            6,\n            6,\n            6,\n            7,\n            8,\n            8,\n            9,\n            9,\n            10,\n            12,\n            12,\n            12,\n            13,\n            14,\n            15,\n            16,\n            17,\n            18,\n            19,\n            19,\n            20,\n            21,\n            22,\n            24,\n            25\n        ],\n        [\n            -1,\n            1,\n            1,\n            1,\n            2,\n            2,\n            4,\n            4,\n            4,\n            5,\n            5,\n            5,\n            8,\n            9,\n            9,\n            10,\n            10,\n            11,\n            13,\n            14,\n            16,\n            17,\n            17,\n            18,\n            20,\n            21,\n            23,\n            25,\n            26,\n            28,\n            29,\n            31,\n            33,\n            35,\n            37,\n            38,\n            40,\n            43,\n            45,\n            47,\n            49\n        ],\n        [\n            -1,\n            1,\n            1,\n            2,\n            2,\n            4,\n            4,\n            6,\n            6,\n            8,\n            8,\n            8,\n            10,\n            12,\n            16,\n            12,\n            17,\n            16,\n            18,\n            21,\n            20,\n            23,\n            23,\n            25,\n            27,\n            29,\n            34,\n            34,\n            35,\n            38,\n            40,\n            43,\n            45,\n            48,\n            51,\n            53,\n            56,\n            59,\n            62,\n            65,\n            68\n        ],\n        [\n            -1,\n            1,\n            1,\n            2,\n            4,\n            4,\n            4,\n            5,\n            6,\n            8,\n            8,\n            11,\n            11,\n            16,\n            16,\n            18,\n            16,\n            19,\n            21,\n            25,\n            25,\n            25,\n            34,\n            30,\n            32,\n            35,\n            37,\n            40,\n            42,\n            45,\n            48,\n            51,\n            54,\n            57,\n            60,\n            63,\n            66,\n            70,\n            74,\n            77,\n            81\n        ]\n    ];\n    qrcodegen2.QrCode = QrCode;\n    function appendBits(val, len, bb) {\n        if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError(\"Value out of range\");\n        for(let i = len - 1; i >= 0; i--)bb.push(val >>> i & 1);\n    }\n    function getBit(x, i) {\n        return (x >>> i & 1) != 0;\n    }\n    function assert(cond) {\n        if (!cond) throw new Error(\"Assertion error\");\n    }\n    const _QrSegment = class {\n        constructor(mode, numChars, bitData){\n            this.mode = mode;\n            this.numChars = numChars;\n            this.bitData = bitData;\n            if (numChars < 0) throw new RangeError(\"Invalid argument\");\n            this.bitData = bitData.slice();\n        }\n        static makeBytes(data) {\n            let bb = [];\n            for (const b of data)appendBits(b, 8, bb);\n            return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);\n        }\n        static makeNumeric(digits) {\n            if (!_QrSegment.isNumeric(digits)) throw new RangeError(\"String contains non-numeric characters\");\n            let bb = [];\n            for(let i = 0; i < digits.length;){\n                const n = Math.min(digits.length - i, 3);\n                appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);\n                i += n;\n            }\n            return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);\n        }\n        static makeAlphanumeric(text) {\n            if (!_QrSegment.isAlphanumeric(text)) throw new RangeError(\"String contains unencodable characters in alphanumeric mode\");\n            let bb = [];\n            let i;\n            for(i = 0; i + 2 <= text.length; i += 2){\n                let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n                temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n                appendBits(temp, 11, bb);\n            }\n            if (i < text.length) appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n            return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);\n        }\n        static makeSegments(text) {\n            if (text == \"\") return [];\n            else if (_QrSegment.isNumeric(text)) return [\n                _QrSegment.makeNumeric(text)\n            ];\n            else if (_QrSegment.isAlphanumeric(text)) return [\n                _QrSegment.makeAlphanumeric(text)\n            ];\n            else return [\n                _QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))\n            ];\n        }\n        static makeEci(assignVal) {\n            let bb = [];\n            if (assignVal < 0) throw new RangeError(\"ECI assignment value out of range\");\n            else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);\n            else if (assignVal < 1 << 14) {\n                appendBits(2, 2, bb);\n                appendBits(assignVal, 14, bb);\n            } else if (assignVal < 1e6) {\n                appendBits(6, 3, bb);\n                appendBits(assignVal, 21, bb);\n            } else throw new RangeError(\"ECI assignment value out of range\");\n            return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);\n        }\n        static isNumeric(text) {\n            return _QrSegment.NUMERIC_REGEX.test(text);\n        }\n        static isAlphanumeric(text) {\n            return _QrSegment.ALPHANUMERIC_REGEX.test(text);\n        }\n        getData() {\n            return this.bitData.slice();\n        }\n        static getTotalBits(segs, version) {\n            let result = 0;\n            for (const seg of segs){\n                const ccbits = seg.mode.numCharCountBits(version);\n                if (seg.numChars >= 1 << ccbits) return Infinity;\n                result += 4 + ccbits + seg.bitData.length;\n            }\n            return result;\n        }\n        static toUtf8ByteArray(str) {\n            str = encodeURI(str);\n            let result = [];\n            for(let i = 0; i < str.length; i++){\n                if (str.charAt(i) != \"%\") result.push(str.charCodeAt(i));\n                else {\n                    result.push(parseInt(str.substr(i + 1, 2), 16));\n                    i += 2;\n                }\n            }\n            return result;\n        }\n    };\n    let QrSegment = _QrSegment;\n    QrSegment.NUMERIC_REGEX = /^[0-9]*$/;\n    QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\\/:-]*$/;\n    QrSegment.ALPHANUMERIC_CHARSET = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\";\n    qrcodegen2.QrSegment = QrSegment;\n})(qrcodegen || (qrcodegen = {}));\n((qrcodegen2)=>{\n    let QrCode;\n    ((QrCode2)=>{\n        const _Ecc = class {\n            constructor(ordinal, formatBits){\n                this.ordinal = ordinal;\n                this.formatBits = formatBits;\n            }\n        };\n        let Ecc = _Ecc;\n        Ecc.LOW = new _Ecc(0, 1);\n        Ecc.MEDIUM = new _Ecc(1, 0);\n        Ecc.QUARTILE = new _Ecc(2, 3);\n        Ecc.HIGH = new _Ecc(3, 2);\n        QrCode2.Ecc = Ecc;\n    })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));\n})(qrcodegen || (qrcodegen = {}));\n((qrcodegen2)=>{\n    let QrSegment;\n    ((QrSegment2)=>{\n        const _Mode = class {\n            constructor(modeBits, numBitsCharCount){\n                this.modeBits = modeBits;\n                this.numBitsCharCount = numBitsCharCount;\n            }\n            numCharCountBits(ver) {\n                return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n            }\n        };\n        let Mode = _Mode;\n        Mode.NUMERIC = new _Mode(1, [\n            10,\n            12,\n            14\n        ]);\n        Mode.ALPHANUMERIC = new _Mode(2, [\n            9,\n            11,\n            13\n        ]);\n        Mode.BYTE = new _Mode(4, [\n            8,\n            16,\n            16\n        ]);\n        Mode.KANJI = new _Mode(8, [\n            8,\n            10,\n            12\n        ]);\n        Mode.ECI = new _Mode(7, [\n            0,\n            0,\n            0\n        ]);\n        QrSegment2.Mode = Mode;\n    })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));\n})(qrcodegen || (qrcodegen = {}));\nvar qrcodegen_default = qrcodegen;\n// src/index.tsx\n/**\n * @license qrcode.react\n * Copyright (c) Paul O'Shannessy\n * SPDX-License-Identifier: ISC\n */ var ERROR_LEVEL_MAP = {\n    L: qrcodegen_default.QrCode.Ecc.LOW,\n    M: qrcodegen_default.QrCode.Ecc.MEDIUM,\n    Q: qrcodegen_default.QrCode.Ecc.QUARTILE,\n    H: qrcodegen_default.QrCode.Ecc.HIGH\n};\nvar DEFAULT_SIZE = 128;\nvar DEFAULT_LEVEL = \"L\";\nvar DEFAULT_BGCOLOR = \"#FFFFFF\";\nvar DEFAULT_FGCOLOR = \"#000000\";\nvar DEFAULT_INCLUDEMARGIN = false;\nvar MARGIN_SIZE = 4;\nvar DEFAULT_IMG_SCALE = 0.1;\nfunction generatePath(modules, margin = 0) {\n    const ops = [];\n    modules.forEach(function(row, y) {\n        let start = null;\n        row.forEach(function(cell, x) {\n            if (!cell && start !== null) {\n                ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);\n                start = null;\n                return;\n            }\n            if (x === row.length - 1) {\n                if (!cell) {\n                    return;\n                }\n                if (start === null) {\n                    ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);\n                } else {\n                    ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);\n                }\n                return;\n            }\n            if (cell && start === null) {\n                start = x;\n            }\n        });\n    });\n    return ops.join(\"\");\n}\nfunction excavateModules(modules, excavation) {\n    return modules.slice().map((row, y)=>{\n        if (y < excavation.y || y >= excavation.y + excavation.h) {\n            return row;\n        }\n        return row.map((cell, x)=>{\n            if (x < excavation.x || x >= excavation.x + excavation.w) {\n                return cell;\n            }\n            return false;\n        });\n    });\n}\nfunction getImageSettings(cells, size, includeMargin, imageSettings) {\n    if (imageSettings == null) {\n        return null;\n    }\n    const margin = includeMargin ? MARGIN_SIZE : 0;\n    const numCells = cells.length + margin * 2;\n    const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);\n    const scale = numCells / size;\n    const w = (imageSettings.width || defaultSize) * scale;\n    const h = (imageSettings.height || defaultSize) * scale;\n    const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;\n    const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;\n    let excavation = null;\n    if (imageSettings.excavate) {\n        let floorX = Math.floor(x);\n        let floorY = Math.floor(y);\n        let ceilW = Math.ceil(w + x - floorX);\n        let ceilH = Math.ceil(h + y - floorY);\n        excavation = {\n            x: floorX,\n            y: floorY,\n            w: ceilW,\n            h: ceilH\n        };\n    }\n    return {\n        x,\n        y,\n        h,\n        w,\n        excavation\n    };\n}\nvar SUPPORTS_PATH2D = function() {\n    try {\n        new Path2D().addPath(new Path2D());\n    } catch (e) {\n        return false;\n    }\n    return true;\n}();\nfunction QRCodeCanvas(props) {\n    const _a = props, { value, size = DEFAULT_SIZE, level = DEFAULT_LEVEL, bgColor = DEFAULT_BGCOLOR, fgColor = DEFAULT_FGCOLOR, includeMargin = DEFAULT_INCLUDEMARGIN, style, imageSettings } = _a, otherProps = __objRest(_a, [\n        \"value\",\n        \"size\",\n        \"level\",\n        \"bgColor\",\n        \"fgColor\",\n        \"includeMargin\",\n        \"style\",\n        \"imageSettings\"\n    ]);\n    const imgSrc = imageSettings == null ? void 0 : imageSettings.src;\n    const _canvas = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const _image = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const [isImgLoaded, setIsImageLoaded] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (_canvas.current != null) {\n            const canvas = _canvas.current;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) {\n                return;\n            }\n            let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n            const margin = includeMargin ? MARGIN_SIZE : 0;\n            const numCells = cells.length + margin * 2;\n            const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);\n            const image = _image.current;\n            const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;\n            if (haveImageToRender) {\n                if (calculatedImageSettings.excavation != null) {\n                    cells = excavateModules(cells, calculatedImageSettings.excavation);\n                }\n            }\n            const pixelRatio = window.devicePixelRatio || 1;\n            canvas.height = canvas.width = size * pixelRatio;\n            const scale = size / numCells * pixelRatio;\n            ctx.scale(scale, scale);\n            ctx.fillStyle = bgColor;\n            ctx.fillRect(0, 0, numCells, numCells);\n            ctx.fillStyle = fgColor;\n            if (SUPPORTS_PATH2D) {\n                ctx.fill(new Path2D(generatePath(cells, margin)));\n            } else {\n                cells.forEach(function(row, rdx) {\n                    row.forEach(function(cell, cdx) {\n                        if (cell) {\n                            ctx.fillRect(cdx + margin, rdx + margin, 1, 1);\n                        }\n                    });\n                });\n            }\n            if (haveImageToRender) {\n                ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);\n            }\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setIsImageLoaded(false);\n    }, [\n        imgSrc\n    ]);\n    const canvasStyle = __spreadValues({\n        height: size,\n        width: size\n    }, style);\n    let img = null;\n    if (imgSrc != null) {\n        img = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n            src: imgSrc,\n            key: imgSrc,\n            style: {\n                display: \"none\"\n            },\n            onLoad: ()=>{\n                setIsImageLoaded(true);\n            },\n            ref: _image\n        });\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"canvas\", __spreadValues({\n        style: canvasStyle,\n        height: size,\n        width: size,\n        ref: _canvas\n    }, otherProps)), img);\n}\nfunction QRCodeSVG(props) {\n    const _a = props, { value, size = DEFAULT_SIZE, level = DEFAULT_LEVEL, bgColor = DEFAULT_BGCOLOR, fgColor = DEFAULT_FGCOLOR, includeMargin = DEFAULT_INCLUDEMARGIN, imageSettings } = _a, otherProps = __objRest(_a, [\n        \"value\",\n        \"size\",\n        \"level\",\n        \"bgColor\",\n        \"fgColor\",\n        \"includeMargin\",\n        \"imageSettings\"\n    ]);\n    let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();\n    const margin = includeMargin ? MARGIN_SIZE : 0;\n    const numCells = cells.length + margin * 2;\n    const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);\n    let image = null;\n    if (imageSettings != null && calculatedImageSettings != null) {\n        if (calculatedImageSettings.excavation != null) {\n            cells = excavateModules(cells, calculatedImageSettings.excavation);\n        }\n        image = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"image\", {\n            xlinkHref: imageSettings.src,\n            height: calculatedImageSettings.h,\n            width: calculatedImageSettings.w,\n            x: calculatedImageSettings.x + margin,\n            y: calculatedImageSettings.y + margin,\n            preserveAspectRatio: \"none\"\n        });\n    }\n    const fgPath = generatePath(cells, margin);\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", __spreadValues({\n        height: size,\n        width: size,\n        viewBox: `0 0 ${numCells} ${numCells}`\n    }, otherProps), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        fill: bgColor,\n        d: `M0,0 h${numCells}v${numCells}H0z`,\n        shapeRendering: \"crispEdges\"\n    }), /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n        fill: fgColor,\n        d: fgPath,\n        shapeRendering: \"crispEdges\"\n    }), image);\n}\nvar QRCode = (props)=>{\n    const _a = props, { renderAs } = _a, otherProps = __objRest(_a, [\n        \"renderAs\"\n    ]);\n    if (renderAs === \"svg\") {\n        return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(QRCodeSVG, __spreadValues({}, otherProps));\n    }\n    return /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(QRCodeCanvas, __spreadValues({}, otherProps));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcXJjb2RlLnJlYWN0QDMuMi4wX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvcXJjb2RlLnJlYWN0L2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsc0JBQXNCRixPQUFPRyxxQkFBcUI7QUFDdEQsSUFBSUMsZUFBZUosT0FBT0ssU0FBUyxDQUFDQyxjQUFjO0FBQ2xELElBQUlDLGVBQWVQLE9BQU9LLFNBQVMsQ0FBQ0csb0JBQW9CO0FBQ3hELElBQUlDLGtCQUFrQixDQUFDQyxLQUFLQyxLQUFLQyxRQUFVRCxPQUFPRCxNQUFNWCxVQUFVVyxLQUFLQyxLQUFLO1FBQUVFLFlBQVk7UUFBTUMsY0FBYztRQUFNQyxVQUFVO1FBQU1IO0lBQU0sS0FBS0YsR0FBRyxDQUFDQyxJQUFJLEdBQUdDO0FBQzFKLElBQUlJLGlCQUFpQixDQUFDQyxHQUFHQztJQUN2QixJQUFLLElBQUlDLFFBQVFELEtBQU1BLENBQUFBLElBQUksQ0FBQyxHQUMxQixJQUFJZCxhQUFhZ0IsSUFBSSxDQUFDRixHQUFHQyxPQUN2QlYsZ0JBQWdCUSxHQUFHRSxNQUFNRCxDQUFDLENBQUNDLEtBQUs7SUFDcEMsSUFBSWpCLHFCQUNGLEtBQUssSUFBSWlCLFFBQVFqQixvQkFBb0JnQixHQUFJO1FBQ3ZDLElBQUlYLGFBQWFhLElBQUksQ0FBQ0YsR0FBR0MsT0FDdkJWLGdCQUFnQlEsR0FBR0UsTUFBTUQsQ0FBQyxDQUFDQyxLQUFLO0lBQ3BDO0lBQ0YsT0FBT0Y7QUFDVDtBQUNBLElBQUlJLFlBQVksQ0FBQ0MsUUFBUUM7SUFDdkIsSUFBSUMsU0FBUyxDQUFDO0lBQ2QsSUFBSyxJQUFJTCxRQUFRRyxPQUNmLElBQUlsQixhQUFhZ0IsSUFBSSxDQUFDRSxRQUFRSCxTQUFTSSxRQUFRRSxPQUFPLENBQUNOLFFBQVEsR0FDN0RLLE1BQU0sQ0FBQ0wsS0FBSyxHQUFH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SztZQUFDLENBQUM7WUFBRztZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtTQUFHO0tBQ3JLO0lBQ0R1RCxPQUFPMUQsMkJBQTJCLEdBQUc7UUFDbkM7WUFBQyxDQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7U0FBRztRQUM3STtZQUFDLENBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtTQUFHO1FBQ3RKO1lBQUMsQ0FBQztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFBSTtZQUFJO1lBQUk7WUFB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QyxHQUFHRjtRQUNIRyxnQkFBZ0I7SUFDbEIsSUFBSTNCO0FBQ047QUFDQSxJQUFJNEIsU0FBUyxDQUFDakQ7SUFDWixNQUFNQyxLQUFLRCxPQUFPLEVBQUVrRCxRQUFRLEVBQUUsR0FBR2pELElBQUlLLGFBQWFyUCxVQUFVZ1AsSUFBSTtRQUFDO0tBQVc7SUFDNUUsSUFBSWlELGFBQWEsT0FBTztRQUN0QixPQUFPLGFBQWEsaUJBQUc1UixnREFBbUIsQ0FBQ29SLFdBQVc5UixlQUFlLENBQUMsR0FBRzBQO0lBQzNFO0lBQ0EsT0FBTyxhQUFhLGlCQUFHaFAsZ0RBQW1CLENBQUN5TyxjQUFjblAsZUFBZSxDQUFDLEdBQUcwUDtBQUM5RTtBQUtFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZHd0LWNyeXB0by1leGNoYW5nZS8uL25vZGVfbW9kdWxlcy8ucG5wbS9xcmNvZGUucmVhY3RAMy4yLjBfcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9xcmNvZGUucmVhY3QvbGliL2VzbS9pbmRleC5qcz84NDI0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wU3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX3Byb3BJc0VudW0gPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgaWYgKF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKGIpKSB7XG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXG4gICAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcbiAgICB9XG4gIHJldHVybiBhO1xufTtcbnZhciBfX29ialJlc3QgPSAoc291cmNlLCBleGNsdWRlKSA9PiB7XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpXG4gICAgaWYgKF9faGFzT3duUHJvcC5jYWxsKHNvdXJjZSwgcHJvcCkgJiYgZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMClcbiAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgaWYgKHNvdXJjZSAhPSBudWxsICYmIF9fZ2V0T3duUHJvcFN5bWJvbHMpXG4gICAgZm9yICh2YXIgcHJvcCBvZiBfX2dldE93blByb3BTeW1ib2xzKHNvdXJjZSkpIHtcbiAgICAgIGlmIChleGNsdWRlLmluZGV4T2YocHJvcCkgPCAwICYmIF9fcHJvcElzRW51bS5jYWxsKHNvdXJjZSwgcHJvcCkpXG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vLyBzcmMvaW5kZXgudHN4XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbi8vIHNyYy90aGlyZC1wYXJ0eS9xcmNvZGVnZW4vaW5kZXgudHNcbi8qKlxuICogQGxpY2Vuc2UgUVIgQ29kZSBnZW5lcmF0b3IgbGlicmFyeSAoVHlwZVNjcmlwdClcbiAqIENvcHlyaWdodCAoYykgUHJvamVjdCBOYXl1a2kuXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4gKi9cbnZhciBxcmNvZGVnZW47XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgY29uc3QgX1FyQ29kZSA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgZGF0YUNvZGV3b3JkcywgbXNrKSB7XG4gICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IGVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgdGhpcy5tb2R1bGVzID0gW107XG4gICAgICB0aGlzLmlzRnVuY3Rpb24gPSBbXTtcbiAgICAgIGlmICh2ZXJzaW9uIDwgX1FyQ29kZS5NSU5fVkVSU0lPTiB8fCB2ZXJzaW9uID4gX1FyQ29kZS5NQVhfVkVSU0lPTilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJWZXJzaW9uIHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGlmIChtc2sgPCAtMSB8fCBtc2sgPiA3KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hc2sgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgdGhpcy5zaXplID0gdmVyc2lvbiAqIDQgKyAxNztcbiAgICAgIGxldCByb3cgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspXG4gICAgICAgIHJvdy5wdXNoKGZhbHNlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzLnB1c2gocm93LnNsaWNlKCkpO1xuICAgICAgICB0aGlzLmlzRnVuY3Rpb24ucHVzaChyb3cuc2xpY2UoKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRyYXdGdW5jdGlvblBhdHRlcm5zKCk7XG4gICAgICBjb25zdCBhbGxDb2Rld29yZHMgPSB0aGlzLmFkZEVjY0FuZEludGVybGVhdmUoZGF0YUNvZGV3b3Jkcyk7XG4gICAgICB0aGlzLmRyYXdDb2Rld29yZHMoYWxsQ29kZXdvcmRzKTtcbiAgICAgIGlmIChtc2sgPT0gLTEpIHtcbiAgICAgICAgbGV0IG1pblBlbmFsdHkgPSAxZTk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hcHBseU1hc2soaSk7XG4gICAgICAgICAgdGhpcy5kcmF3Rm9ybWF0Qml0cyhpKTtcbiAgICAgICAgICBjb25zdCBwZW5hbHR5ID0gdGhpcy5nZXRQZW5hbHR5U2NvcmUoKTtcbiAgICAgICAgICBpZiAocGVuYWx0eSA8IG1pblBlbmFsdHkpIHtcbiAgICAgICAgICAgIG1zayA9IGk7XG4gICAgICAgICAgICBtaW5QZW5hbHR5ID0gcGVuYWx0eTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5hcHBseU1hc2soaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFzc2VydCgwIDw9IG1zayAmJiBtc2sgPD0gNyk7XG4gICAgICB0aGlzLm1hc2sgPSBtc2s7XG4gICAgICB0aGlzLmFwcGx5TWFzayhtc2spO1xuICAgICAgdGhpcy5kcmF3Rm9ybWF0Qml0cyhtc2spO1xuICAgICAgdGhpcy5pc0Z1bmN0aW9uID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVUZXh0KHRleHQsIGVjbCkge1xuICAgICAgY29uc3Qgc2VncyA9IHFyY29kZWdlbjIuUXJTZWdtZW50Lm1ha2VTZWdtZW50cyh0ZXh0KTtcbiAgICAgIHJldHVybiBfUXJDb2RlLmVuY29kZVNlZ21lbnRzKHNlZ3MsIGVjbCk7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGVCaW5hcnkoZGF0YSwgZWNsKSB7XG4gICAgICBjb25zdCBzZWcgPSBxcmNvZGVnZW4yLlFyU2VnbWVudC5tYWtlQnl0ZXMoZGF0YSk7XG4gICAgICByZXR1cm4gX1FyQ29kZS5lbmNvZGVTZWdtZW50cyhbc2VnXSwgZWNsKTtcbiAgICB9XG4gICAgc3RhdGljIGVuY29kZVNlZ21lbnRzKHNlZ3MsIGVjbCwgbWluVmVyc2lvbiA9IDEsIG1heFZlcnNpb24gPSA0MCwgbWFzayA9IC0xLCBib29zdEVjbCA9IHRydWUpIHtcbiAgICAgIGlmICghKF9RckNvZGUuTUlOX1ZFUlNJT04gPD0gbWluVmVyc2lvbiAmJiBtaW5WZXJzaW9uIDw9IG1heFZlcnNpb24gJiYgbWF4VmVyc2lvbiA8PSBfUXJDb2RlLk1BWF9WRVJTSU9OKSB8fCBtYXNrIDwgLTEgfHwgbWFzayA+IDcpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCB2YWx1ZVwiKTtcbiAgICAgIGxldCB2ZXJzaW9uO1xuICAgICAgbGV0IGRhdGFVc2VkQml0cztcbiAgICAgIGZvciAodmVyc2lvbiA9IG1pblZlcnNpb247IDsgdmVyc2lvbisrKSB7XG4gICAgICAgIGNvbnN0IGRhdGFDYXBhY2l0eUJpdHMyID0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgICBjb25zdCB1c2VkQml0cyA9IFFyU2VnbWVudC5nZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbik7XG4gICAgICAgIGlmICh1c2VkQml0cyA8PSBkYXRhQ2FwYWNpdHlCaXRzMikge1xuICAgICAgICAgIGRhdGFVc2VkQml0cyA9IHVzZWRCaXRzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uID49IG1heFZlcnNpb24pXG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEYXRhIHRvbyBsb25nXCIpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBuZXdFY2wgb2YgW19RckNvZGUuRWNjLk1FRElVTSwgX1FyQ29kZS5FY2MuUVVBUlRJTEUsIF9RckNvZGUuRWNjLkhJR0hdKSB7XG4gICAgICAgIGlmIChib29zdEVjbCAmJiBkYXRhVXNlZEJpdHMgPD0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIG5ld0VjbCkgKiA4KVxuICAgICAgICAgIGVjbCA9IG5ld0VjbDtcbiAgICAgIH1cbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2Vncykge1xuICAgICAgICBhcHBlbmRCaXRzKHNlZy5tb2RlLm1vZGVCaXRzLCA0LCBiYik7XG4gICAgICAgIGFwcGVuZEJpdHMoc2VnLm51bUNoYXJzLCBzZWcubW9kZS5udW1DaGFyQ291bnRCaXRzKHZlcnNpb24pLCBiYik7XG4gICAgICAgIGZvciAoY29uc3QgYiBvZiBzZWcuZ2V0RGF0YSgpKVxuICAgICAgICAgIGJiLnB1c2goYik7XG4gICAgICB9XG4gICAgICBhc3NlcnQoYmIubGVuZ3RoID09IGRhdGFVc2VkQml0cyk7XG4gICAgICBjb25zdCBkYXRhQ2FwYWNpdHlCaXRzID0gX1FyQ29kZS5nZXROdW1EYXRhQ29kZXdvcmRzKHZlcnNpb24sIGVjbCkgKiA4O1xuICAgICAgYXNzZXJ0KGJiLmxlbmd0aCA8PSBkYXRhQ2FwYWNpdHlCaXRzKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgTWF0aC5taW4oNCwgZGF0YUNhcGFjaXR5Qml0cyAtIGJiLmxlbmd0aCksIGJiKTtcbiAgICAgIGFwcGVuZEJpdHMoMCwgKDggLSBiYi5sZW5ndGggJSA4KSAlIDgsIGJiKTtcbiAgICAgIGFzc2VydChiYi5sZW5ndGggJSA4ID09IDApO1xuICAgICAgZm9yIChsZXQgcGFkQnl0ZSA9IDIzNjsgYmIubGVuZ3RoIDwgZGF0YUNhcGFjaXR5Qml0czsgcGFkQnl0ZSBePSAyMzYgXiAxNylcbiAgICAgICAgYXBwZW5kQml0cyhwYWRCeXRlLCA4LCBiYik7XG4gICAgICBsZXQgZGF0YUNvZGV3b3JkcyA9IFtdO1xuICAgICAgd2hpbGUgKGRhdGFDb2Rld29yZHMubGVuZ3RoICogOCA8IGJiLmxlbmd0aClcbiAgICAgICAgZGF0YUNvZGV3b3Jkcy5wdXNoKDApO1xuICAgICAgYmIuZm9yRWFjaCgoYiwgaSkgPT4gZGF0YUNvZGV3b3Jkc1tpID4+PiAzXSB8PSBiIDw8IDcgLSAoaSAmIDcpKTtcbiAgICAgIHJldHVybiBuZXcgX1FyQ29kZSh2ZXJzaW9uLCBlY2wsIGRhdGFDb2Rld29yZHMsIG1hc2spO1xuICAgIH1cbiAgICBnZXRNb2R1bGUoeCwgeSkge1xuICAgICAgcmV0dXJuIDAgPD0geCAmJiB4IDwgdGhpcy5zaXplICYmIDAgPD0geSAmJiB5IDwgdGhpcy5zaXplICYmIHRoaXMubW9kdWxlc1t5XVt4XTtcbiAgICB9XG4gICAgZ2V0TW9kdWxlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZHVsZXM7XG4gICAgfVxuICAgIGRyYXdGdW5jdGlvblBhdHRlcm5zKCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDYsIGksIGkgJSAyID09IDApO1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGksIDYsIGkgJSAyID09IDApO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmF3RmluZGVyUGF0dGVybigzLCAzKTtcbiAgICAgIHRoaXMuZHJhd0ZpbmRlclBhdHRlcm4odGhpcy5zaXplIC0gNCwgMyk7XG4gICAgICB0aGlzLmRyYXdGaW5kZXJQYXR0ZXJuKDMsIHRoaXMuc2l6ZSAtIDQpO1xuICAgICAgY29uc3QgYWxpZ25QYXRQb3MgPSB0aGlzLmdldEFsaWdubWVudFBhdHRlcm5Qb3NpdGlvbnMoKTtcbiAgICAgIGNvbnN0IG51bUFsaWduID0gYWxpZ25QYXRQb3MubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BbGlnbjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQWxpZ247IGorKykge1xuICAgICAgICAgIGlmICghKGkgPT0gMCAmJiBqID09IDAgfHwgaSA9PSAwICYmIGogPT0gbnVtQWxpZ24gLSAxIHx8IGkgPT0gbnVtQWxpZ24gLSAxICYmIGogPT0gMCkpXG4gICAgICAgICAgICB0aGlzLmRyYXdBbGlnbm1lbnRQYXR0ZXJuKGFsaWduUGF0UG9zW2ldLCBhbGlnblBhdFBvc1tqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZHJhd0Zvcm1hdEJpdHMoMCk7XG4gICAgICB0aGlzLmRyYXdWZXJzaW9uKCk7XG4gICAgfVxuICAgIGRyYXdGb3JtYXRCaXRzKG1hc2spIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsLmZvcm1hdEJpdHMgPDwgMyB8IG1hc2s7XG4gICAgICBsZXQgcmVtID0gZGF0YTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKylcbiAgICAgICAgcmVtID0gcmVtIDw8IDEgXiAocmVtID4+PiA5KSAqIDEzMzU7XG4gICAgICBjb25zdCBiaXRzID0gKGRhdGEgPDwgMTAgfCByZW0pIF4gMjE1MjI7XG4gICAgICBhc3NlcnQoYml0cyA+Pj4gMTUgPT0gMCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSA1OyBpKyspXG4gICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgaSwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgNywgZ2V0Qml0KGJpdHMsIDYpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoOCwgOCwgZ2V0Qml0KGJpdHMsIDcpKTtcbiAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoNywgOCwgZ2V0Qml0KGJpdHMsIDgpKTtcbiAgICAgIGZvciAobGV0IGkgPSA5OyBpIDwgMTU7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSgxNCAtIGksIDgsIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh0aGlzLnNpemUgLSAxIC0gaSwgOCwgZ2V0Qml0KGJpdHMsIGkpKTtcbiAgICAgIGZvciAobGV0IGkgPSA4OyBpIDwgMTU7IGkrKylcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSg4LCB0aGlzLnNpemUgLSAxNSArIGksIGdldEJpdChiaXRzLCBpKSk7XG4gICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKDgsIHRoaXMuc2l6ZSAtIDgsIHRydWUpO1xuICAgIH1cbiAgICBkcmF3VmVyc2lvbigpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPCA3KVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgcmVtID0gdGhpcy52ZXJzaW9uO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKVxuICAgICAgICByZW0gPSByZW0gPDwgMSBeIChyZW0gPj4+IDExKSAqIDc5NzM7XG4gICAgICBjb25zdCBiaXRzID0gdGhpcy52ZXJzaW9uIDw8IDEyIHwgcmVtO1xuICAgICAgYXNzZXJ0KGJpdHMgPj4+IDE4ID09IDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxODsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gZ2V0Qml0KGJpdHMsIGkpO1xuICAgICAgICBjb25zdCBhID0gdGhpcy5zaXplIC0gMTEgKyBpICUgMztcbiAgICAgICAgY29uc3QgYiA9IE1hdGguZmxvb3IoaSAvIDMpO1xuICAgICAgICB0aGlzLnNldEZ1bmN0aW9uTW9kdWxlKGEsIGIsIGNvbG9yKTtcbiAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZShiLCBhLCBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGRyYXdGaW5kZXJQYXR0ZXJuKHgsIHkpIHtcbiAgICAgIGZvciAobGV0IGR5ID0gLTQ7IGR5IDw9IDQ7IGR5KyspIHtcbiAgICAgICAgZm9yIChsZXQgZHggPSAtNDsgZHggPD0gNDsgZHgrKykge1xuICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLm1heChNYXRoLmFicyhkeCksIE1hdGguYWJzKGR5KSk7XG4gICAgICAgICAgY29uc3QgeHggPSB4ICsgZHg7XG4gICAgICAgICAgY29uc3QgeXkgPSB5ICsgZHk7XG4gICAgICAgICAgaWYgKDAgPD0geHggJiYgeHggPCB0aGlzLnNpemUgJiYgMCA8PSB5eSAmJiB5eSA8IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHRoaXMuc2V0RnVuY3Rpb25Nb2R1bGUoeHgsIHl5LCBkaXN0ICE9IDIgJiYgZGlzdCAhPSA0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkcmF3QWxpZ25tZW50UGF0dGVybih4LCB5KSB7XG4gICAgICBmb3IgKGxldCBkeSA9IC0yOyBkeSA8PSAyOyBkeSsrKSB7XG4gICAgICAgIGZvciAobGV0IGR4ID0gLTI7IGR4IDw9IDI7IGR4KyspXG4gICAgICAgICAgdGhpcy5zZXRGdW5jdGlvbk1vZHVsZSh4ICsgZHgsIHkgKyBkeSwgTWF0aC5tYXgoTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpICE9IDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRGdW5jdGlvbk1vZHVsZSh4LCB5LCBpc0RhcmspIHtcbiAgICAgIHRoaXMubW9kdWxlc1t5XVt4XSA9IGlzRGFyaztcbiAgICAgIHRoaXMuaXNGdW5jdGlvblt5XVt4XSA9IHRydWU7XG4gICAgfVxuICAgIGFkZEVjY0FuZEludGVybGVhdmUoZGF0YSkge1xuICAgICAgY29uc3QgdmVyID0gdGhpcy52ZXJzaW9uO1xuICAgICAgY29uc3QgZWNsID0gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCAhPSBfUXJDb2RlLmdldE51bURhdGFDb2Rld29yZHModmVyLCBlY2wpKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7XG4gICAgICBjb25zdCBudW1CbG9ja3MgPSBfUXJDb2RlLk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLU1tlY2wub3JkaW5hbF1bdmVyXTtcbiAgICAgIGNvbnN0IGJsb2NrRWNjTGVuID0gX1FyQ29kZS5FQ0NfQ09ERVdPUkRTX1BFUl9CTE9DS1tlY2wub3JkaW5hbF1bdmVyXTtcbiAgICAgIGNvbnN0IHJhd0NvZGV3b3JkcyA9IE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIC8gOCk7XG4gICAgICBjb25zdCBudW1TaG9ydEJsb2NrcyA9IG51bUJsb2NrcyAtIHJhd0NvZGV3b3JkcyAlIG51bUJsb2NrcztcbiAgICAgIGNvbnN0IHNob3J0QmxvY2tMZW4gPSBNYXRoLmZsb29yKHJhd0NvZGV3b3JkcyAvIG51bUJsb2Nrcyk7XG4gICAgICBsZXQgYmxvY2tzID0gW107XG4gICAgICBjb25zdCByc0RpdiA9IF9RckNvZGUucmVlZFNvbG9tb25Db21wdXRlRGl2aXNvcihibG9ja0VjY0xlbik7XG4gICAgICBmb3IgKGxldCBpID0gMCwgayA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgICBsZXQgZGF0ID0gZGF0YS5zbGljZShrLCBrICsgc2hvcnRCbG9ja0xlbiAtIGJsb2NrRWNjTGVuICsgKGkgPCBudW1TaG9ydEJsb2NrcyA/IDAgOiAxKSk7XG4gICAgICAgIGsgKz0gZGF0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgZWNjID0gX1FyQ29kZS5yZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0LCByc0Rpdik7XG4gICAgICAgIGlmIChpIDwgbnVtU2hvcnRCbG9ja3MpXG4gICAgICAgICAgZGF0LnB1c2goMCk7XG4gICAgICAgIGJsb2Nrcy5wdXNoKGRhdC5jb25jYXQoZWNjKSk7XG4gICAgICB9XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2Nrc1swXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGopID0+IHtcbiAgICAgICAgICBpZiAoaSAhPSBzaG9ydEJsb2NrTGVuIC0gYmxvY2tFY2NMZW4gfHwgaiA+PSBudW1TaG9ydEJsb2NrcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGJsb2NrW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhc3NlcnQocmVzdWx0Lmxlbmd0aCA9PSByYXdDb2Rld29yZHMpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZHJhd0NvZGV3b3JkcyhkYXRhKSB7XG4gICAgICBpZiAoZGF0YS5sZW5ndGggIT0gTWF0aC5mbG9vcihfUXJDb2RlLmdldE51bVJhd0RhdGFNb2R1bGVzKHRoaXMudmVyc2lvbikgLyA4KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChsZXQgcmlnaHQgPSB0aGlzLnNpemUgLSAxOyByaWdodCA+PSAxOyByaWdodCAtPSAyKSB7XG4gICAgICAgIGlmIChyaWdodCA9PSA2KVxuICAgICAgICAgIHJpZ2h0ID0gNTtcbiAgICAgICAgZm9yIChsZXQgdmVydCA9IDA7IHZlcnQgPCB0aGlzLnNpemU7IHZlcnQrKykge1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gcmlnaHQgLSBqO1xuICAgICAgICAgICAgY29uc3QgdXB3YXJkID0gKHJpZ2h0ICsgMSAmIDIpID09IDA7XG4gICAgICAgICAgICBjb25zdCB5ID0gdXB3YXJkID8gdGhpcy5zaXplIC0gMSAtIHZlcnQgOiB2ZXJ0O1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRnVuY3Rpb25beV1beF0gJiYgaSA8IGRhdGEubGVuZ3RoICogOCkge1xuICAgICAgICAgICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSBnZXRCaXQoZGF0YVtpID4+PiAzXSwgNyAtIChpICYgNykpO1xuICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA9PSBkYXRhLmxlbmd0aCAqIDgpO1xuICAgIH1cbiAgICBhcHBseU1hc2sobWFzaykge1xuICAgICAgaWYgKG1hc2sgPCAwIHx8IG1hc2sgPiA3KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hc2sgdmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgICAgbGV0IGludmVydDtcbiAgICAgICAgICBzd2l0Y2ggKG1hc2spIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKyB5KSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGludmVydCA9IHkgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBpbnZlcnQgPSB4ICUgMyA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKyB5KSAlIDMgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGludmVydCA9IChNYXRoLmZsb29yKHggLyAzKSArIE1hdGguZmxvb3IoeSAvIDIpKSAlIDIgPT0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGludmVydCA9IHggKiB5ICUgMiArIHggKiB5ICUgMyA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgaW52ZXJ0ID0gKHggKiB5ICUgMiArIHggKiB5ICUgMykgJSAyID09IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBpbnZlcnQgPSAoKHggKyB5KSAlIDIgKyB4ICogeSAlIDMpICUgMiA9PSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuaXNGdW5jdGlvblt5XVt4XSAmJiBpbnZlcnQpXG4gICAgICAgICAgICB0aGlzLm1vZHVsZXNbeV1beF0gPSAhdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGdldFBlbmFsdHlTY29yZSgpIHtcbiAgICAgIGxldCByZXN1bHQgPSAwO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLnNpemU7IHkrKykge1xuICAgICAgICBsZXQgcnVuQ29sb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJ1blggPSAwO1xuICAgICAgICBsZXQgcnVuSGlzdG9yeSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLnNpemU7IHgrKykge1xuICAgICAgICAgIGlmICh0aGlzLm1vZHVsZXNbeV1beF0gPT0gcnVuQ29sb3IpIHtcbiAgICAgICAgICAgIHJ1blgrKztcbiAgICAgICAgICAgIGlmIChydW5YID09IDUpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjE7XG4gICAgICAgICAgICBlbHNlIGlmIChydW5YID4gNSlcbiAgICAgICAgICAgICAgcmVzdWx0Kys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkocnVuWCwgcnVuSGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoIXJ1bkNvbG9yKVxuICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5maW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgICAgICAgIHJ1bkNvbG9yID0gdGhpcy5tb2R1bGVzW3ldW3hdO1xuICAgICAgICAgICAgcnVuWCA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlUZXJtaW5hdGVBbmRDb3VudChydW5Db2xvciwgcnVuWCwgcnVuSGlzdG9yeSkgKiBfUXJDb2RlLlBFTkFMVFlfTjM7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuc2l6ZTsgeCsrKSB7XG4gICAgICAgIGxldCBydW5Db2xvciA9IGZhbHNlO1xuICAgICAgICBsZXQgcnVuWSA9IDA7XG4gICAgICAgIGxldCBydW5IaXN0b3J5ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuc2l6ZTsgeSsrKSB7XG4gICAgICAgICAgaWYgKHRoaXMubW9kdWxlc1t5XVt4XSA9PSBydW5Db2xvcikge1xuICAgICAgICAgICAgcnVuWSsrO1xuICAgICAgICAgICAgaWYgKHJ1blkgPT0gNSlcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IF9RckNvZGUuUEVOQUxUWV9OMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1blkgPiA1KVxuICAgICAgICAgICAgICByZXN1bHQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShydW5ZLCBydW5IaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICghcnVuQ29sb3IpXG4gICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpICogX1FyQ29kZS5QRU5BTFRZX04zO1xuICAgICAgICAgICAgcnVuQ29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgICBydW5ZID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMuZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KHJ1bkNvbG9yLCBydW5ZLCBydW5IaXN0b3J5KSAqIF9RckNvZGUuUEVOQUxUWV9OMztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdGhpcy5zaXplIC0gMTsgeSsrKSB7XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy5zaXplIC0gMTsgeCsrKSB7XG4gICAgICAgICAgY29uc3QgY29sb3IgPSB0aGlzLm1vZHVsZXNbeV1beF07XG4gICAgICAgICAgaWYgKGNvbG9yID09IHRoaXMubW9kdWxlc1t5XVt4ICsgMV0gJiYgY29sb3IgPT0gdGhpcy5tb2R1bGVzW3kgKyAxXVt4XSAmJiBjb2xvciA9PSB0aGlzLm1vZHVsZXNbeSArIDFdW3ggKyAxXSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBfUXJDb2RlLlBFTkFMVFlfTjI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBkYXJrID0gMDtcbiAgICAgIGZvciAoY29uc3Qgcm93IG9mIHRoaXMubW9kdWxlcylcbiAgICAgICAgZGFyayA9IHJvdy5yZWR1Y2UoKHN1bSwgY29sb3IpID0+IHN1bSArIChjb2xvciA/IDEgOiAwKSwgZGFyayk7XG4gICAgICBjb25zdCB0b3RhbCA9IHRoaXMuc2l6ZSAqIHRoaXMuc2l6ZTtcbiAgICAgIGNvbnN0IGsgPSBNYXRoLmNlaWwoTWF0aC5hYnMoZGFyayAqIDIwIC0gdG90YWwgKiAxMCkgLyB0b3RhbCkgLSAxO1xuICAgICAgYXNzZXJ0KDAgPD0gayAmJiBrIDw9IDkpO1xuICAgICAgcmVzdWx0ICs9IGsgKiBfUXJDb2RlLlBFTkFMVFlfTjQ7XG4gICAgICBhc3NlcnQoMCA8PSByZXN1bHQgJiYgcmVzdWx0IDw9IDI1Njg4ODgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0QWxpZ25tZW50UGF0dGVyblBvc2l0aW9ucygpIHtcbiAgICAgIGlmICh0aGlzLnZlcnNpb24gPT0gMSlcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG51bUFsaWduID0gTWF0aC5mbG9vcih0aGlzLnZlcnNpb24gLyA3KSArIDI7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLnZlcnNpb24gPT0gMzIgPyAyNiA6IE1hdGguY2VpbCgodGhpcy52ZXJzaW9uICogNCArIDQpIC8gKG51bUFsaWduICogMiAtIDIpKSAqIDI7XG4gICAgICAgIGxldCByZXN1bHQgPSBbNl07XG4gICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuc2l6ZSAtIDc7IHJlc3VsdC5sZW5ndGggPCBudW1BbGlnbjsgcG9zIC09IHN0ZXApXG4gICAgICAgICAgcmVzdWx0LnNwbGljZSgxLCAwLCBwb3MpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0TnVtUmF3RGF0YU1vZHVsZXModmVyKSB7XG4gICAgICBpZiAodmVyIDwgX1FyQ29kZS5NSU5fVkVSU0lPTiB8fCB2ZXIgPiBfUXJDb2RlLk1BWF9WRVJTSU9OKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlZlcnNpb24gbnVtYmVyIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGxldCByZXN1bHQgPSAoMTYgKiB2ZXIgKyAxMjgpICogdmVyICsgNjQ7XG4gICAgICBpZiAodmVyID49IDIpIHtcbiAgICAgICAgY29uc3QgbnVtQWxpZ24gPSBNYXRoLmZsb29yKHZlciAvIDcpICsgMjtcbiAgICAgICAgcmVzdWx0IC09ICgyNSAqIG51bUFsaWduIC0gMTApICogbnVtQWxpZ24gLSA1NTtcbiAgICAgICAgaWYgKHZlciA+PSA3KVxuICAgICAgICAgIHJlc3VsdCAtPSAzNjtcbiAgICAgIH1cbiAgICAgIGFzc2VydCgyMDggPD0gcmVzdWx0ICYmIHJlc3VsdCA8PSAyOTY0OCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TnVtRGF0YUNvZGV3b3Jkcyh2ZXIsIGVjbCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IoX1FyQ29kZS5nZXROdW1SYXdEYXRhTW9kdWxlcyh2ZXIpIC8gOCkgLSBfUXJDb2RlLkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLW2VjbC5vcmRpbmFsXVt2ZXJdICogX1FyQ29kZS5OVU1fRVJST1JfQ09SUkVDVElPTl9CTE9DS1NbZWNsLm9yZGluYWxdW3Zlcl07XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbkNvbXB1dGVEaXZpc29yKGRlZ3JlZSkge1xuICAgICAgaWYgKGRlZ3JlZSA8IDEgfHwgZGVncmVlID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkRlZ3JlZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZSAtIDE7IGkrKylcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICByZXN1bHQucHVzaCgxKTtcbiAgICAgIGxldCByb290ID0gMTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVncmVlOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXN1bHRbal0gPSBfUXJDb2RlLnJlZWRTb2xvbW9uTXVsdGlwbHkocmVzdWx0W2pdLCByb290KTtcbiAgICAgICAgICBpZiAoaiArIDEgPCByZXN1bHQubGVuZ3RoKVxuICAgICAgICAgICAgcmVzdWx0W2pdIF49IHJlc3VsdFtqICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IF9RckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShyb290LCAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbkNvbXB1dGVSZW1haW5kZXIoZGF0YSwgZGl2aXNvcikge1xuICAgICAgbGV0IHJlc3VsdCA9IGRpdmlzb3IubWFwKChfKSA9PiAwKTtcbiAgICAgIGZvciAoY29uc3QgYiBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IGIgXiByZXN1bHQuc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgIGRpdmlzb3IuZm9yRWFjaCgoY29lZiwgaSkgPT4gcmVzdWx0W2ldIF49IF9RckNvZGUucmVlZFNvbG9tb25NdWx0aXBseShjb2VmLCBmYWN0b3IpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyByZWVkU29sb21vbk11bHRpcGx5KHgsIHkpIHtcbiAgICAgIGlmICh4ID4+PiA4ICE9IDAgfHwgeSA+Pj4gOCAhPSAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ5dGUgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgbGV0IHogPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHogPSB6IDw8IDEgXiAoeiA+Pj4gNykgKiAyODU7XG4gICAgICAgIHogXj0gKHkgPj4+IGkgJiAxKSAqIHg7XG4gICAgICB9XG4gICAgICBhc3NlcnQoeiA+Pj4gOCA9PSAwKTtcbiAgICAgIHJldHVybiB6O1xuICAgIH1cbiAgICBmaW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyhydW5IaXN0b3J5KSB7XG4gICAgICBjb25zdCBuID0gcnVuSGlzdG9yeVsxXTtcbiAgICAgIGFzc2VydChuIDw9IHRoaXMuc2l6ZSAqIDMpO1xuICAgICAgY29uc3QgY29yZSA9IG4gPiAwICYmIHJ1bkhpc3RvcnlbMl0gPT0gbiAmJiBydW5IaXN0b3J5WzNdID09IG4gKiAzICYmIHJ1bkhpc3RvcnlbNF0gPT0gbiAmJiBydW5IaXN0b3J5WzVdID09IG47XG4gICAgICByZXR1cm4gKGNvcmUgJiYgcnVuSGlzdG9yeVswXSA+PSBuICogNCAmJiBydW5IaXN0b3J5WzZdID49IG4gPyAxIDogMCkgKyAoY29yZSAmJiBydW5IaXN0b3J5WzZdID49IG4gKiA0ICYmIHJ1bkhpc3RvcnlbMF0gPj0gbiA/IDEgOiAwKTtcbiAgICB9XG4gICAgZmluZGVyUGVuYWx0eVRlcm1pbmF0ZUFuZENvdW50KGN1cnJlbnRSdW5Db2xvciwgY3VycmVudFJ1bkxlbmd0aCwgcnVuSGlzdG9yeSkge1xuICAgICAgaWYgKGN1cnJlbnRSdW5Db2xvcikge1xuICAgICAgICB0aGlzLmZpbmRlclBlbmFsdHlBZGRIaXN0b3J5KGN1cnJlbnRSdW5MZW5ndGgsIHJ1bkhpc3RvcnkpO1xuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRSdW5MZW5ndGggKz0gdGhpcy5zaXplO1xuICAgICAgdGhpcy5maW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmRlclBlbmFsdHlDb3VudFBhdHRlcm5zKHJ1bkhpc3RvcnkpO1xuICAgIH1cbiAgICBmaW5kZXJQZW5hbHR5QWRkSGlzdG9yeShjdXJyZW50UnVuTGVuZ3RoLCBydW5IaXN0b3J5KSB7XG4gICAgICBpZiAocnVuSGlzdG9yeVswXSA9PSAwKVxuICAgICAgICBjdXJyZW50UnVuTGVuZ3RoICs9IHRoaXMuc2l6ZTtcbiAgICAgIHJ1bkhpc3RvcnkucG9wKCk7XG4gICAgICBydW5IaXN0b3J5LnVuc2hpZnQoY3VycmVudFJ1bkxlbmd0aCk7XG4gICAgfVxuICB9O1xuICBsZXQgUXJDb2RlID0gX1FyQ29kZTtcbiAgUXJDb2RlLk1JTl9WRVJTSU9OID0gMTtcbiAgUXJDb2RlLk1BWF9WRVJTSU9OID0gNDA7XG4gIFFyQ29kZS5QRU5BTFRZX04xID0gMztcbiAgUXJDb2RlLlBFTkFMVFlfTjIgPSAzO1xuICBRckNvZGUuUEVOQUxUWV9OMyA9IDQwO1xuICBRckNvZGUuUEVOQUxUWV9ONCA9IDEwO1xuICBRckNvZGUuRUNDX0NPREVXT1JEU19QRVJfQkxPQ0sgPSBbXG4gICAgWy0xLCA3LCAxMCwgMTUsIDIwLCAyNiwgMTgsIDIwLCAyNCwgMzAsIDE4LCAyMCwgMjQsIDI2LCAzMCwgMjIsIDI0LCAyOCwgMzAsIDI4LCAyOCwgMjgsIDI4LCAzMCwgMzAsIDI2LCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBbLTEsIDEwLCAxNiwgMjYsIDE4LCAyNCwgMTYsIDE4LCAyMiwgMjIsIDI2LCAzMCwgMjIsIDIyLCAyNCwgMjQsIDI4LCAyOCwgMjYsIDI2LCAyNiwgMjYsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4XSxcbiAgICBbLTEsIDEzLCAyMiwgMTgsIDI2LCAxOCwgMjQsIDE4LCAyMiwgMjAsIDI0LCAyOCwgMjYsIDI0LCAyMCwgMzAsIDI0LCAyOCwgMjgsIDI2LCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBbLTEsIDE3LCAyOCwgMjIsIDE2LCAyMiwgMjgsIDI2LCAyNiwgMjQsIDI4LCAyNCwgMjgsIDIyLCAyNCwgMjQsIDMwLCAyOCwgMjgsIDI2LCAyOCwgMzAsIDI0LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXVxuICBdO1xuICBRckNvZGUuTlVNX0VSUk9SX0NPUlJFQ1RJT05fQkxPQ0tTID0gW1xuICAgIFstMSwgMSwgMSwgMSwgMSwgMSwgMiwgMiwgMiwgMiwgNCwgNCwgNCwgNCwgNCwgNiwgNiwgNiwgNiwgNywgOCwgOCwgOSwgOSwgMTAsIDEyLCAxMiwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAxOSwgMjAsIDIxLCAyMiwgMjQsIDI1XSxcbiAgICBbLTEsIDEsIDEsIDEsIDIsIDIsIDQsIDQsIDQsIDUsIDUsIDUsIDgsIDksIDksIDEwLCAxMCwgMTEsIDEzLCAxNCwgMTYsIDE3LCAxNywgMTgsIDIwLCAyMSwgMjMsIDI1LCAyNiwgMjgsIDI5LCAzMSwgMzMsIDM1LCAzNywgMzgsIDQwLCA0MywgNDUsIDQ3LCA0OV0sXG4gICAgWy0xLCAxLCAxLCAyLCAyLCA0LCA0LCA2LCA2LCA4LCA4LCA4LCAxMCwgMTIsIDE2LCAxMiwgMTcsIDE2LCAxOCwgMjEsIDIwLCAyMywgMjMsIDI1LCAyNywgMjksIDM0LCAzNCwgMzUsIDM4LCA0MCwgNDMsIDQ1LCA0OCwgNTEsIDUzLCA1NiwgNTksIDYyLCA2NSwgNjhdLFxuICAgIFstMSwgMSwgMSwgMiwgNCwgNCwgNCwgNSwgNiwgOCwgOCwgMTEsIDExLCAxNiwgMTYsIDE4LCAxNiwgMTksIDIxLCAyNSwgMjUsIDI1LCAzNCwgMzAsIDMyLCAzNSwgMzcsIDQwLCA0MiwgNDUsIDQ4LCA1MSwgNTQsIDU3LCA2MCwgNjMsIDY2LCA3MCwgNzQsIDc3LCA4MV1cbiAgXTtcbiAgcXJjb2RlZ2VuMi5RckNvZGUgPSBRckNvZGU7XG4gIGZ1bmN0aW9uIGFwcGVuZEJpdHModmFsLCBsZW4sIGJiKSB7XG4gICAgaWYgKGxlbiA8IDAgfHwgbGVuID4gMzEgfHwgdmFsID4+PiBsZW4gIT0gMClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVmFsdWUgb3V0IG9mIHJhbmdlXCIpO1xuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSlcbiAgICAgIGJiLnB1c2godmFsID4+PiBpICYgMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Qml0KHgsIGkpIHtcbiAgICByZXR1cm4gKHggPj4+IGkgJiAxKSAhPSAwO1xuICB9XG4gIGZ1bmN0aW9uIGFzc2VydChjb25kKSB7XG4gICAgaWYgKCFjb25kKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGVycm9yXCIpO1xuICB9XG4gIGNvbnN0IF9RclNlZ21lbnQgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IobW9kZSwgbnVtQ2hhcnMsIGJpdERhdGEpIHtcbiAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICB0aGlzLm51bUNoYXJzID0gbnVtQ2hhcnM7XG4gICAgICB0aGlzLmJpdERhdGEgPSBiaXREYXRhO1xuICAgICAgaWYgKG51bUNoYXJzIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICAgICAgdGhpcy5iaXREYXRhID0gYml0RGF0YS5zbGljZSgpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZUJ5dGVzKGRhdGEpIHtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBiIG9mIGRhdGEpXG4gICAgICAgIGFwcGVuZEJpdHMoYiwgOCwgYmIpO1xuICAgICAgcmV0dXJuIG5ldyBfUXJTZWdtZW50KF9RclNlZ21lbnQuTW9kZS5CWVRFLCBkYXRhLmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZU51bWVyaWMoZGlnaXRzKSB7XG4gICAgICBpZiAoIV9RclNlZ21lbnQuaXNOdW1lcmljKGRpZ2l0cykpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU3RyaW5nIGNvbnRhaW5zIG5vbi1udW1lcmljIGNoYXJhY3RlcnNcIik7XG4gICAgICBsZXQgYmIgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlnaXRzLmxlbmd0aDsgKSB7XG4gICAgICAgIGNvbnN0IG4gPSBNYXRoLm1pbihkaWdpdHMubGVuZ3RoIC0gaSwgMyk7XG4gICAgICAgIGFwcGVuZEJpdHMocGFyc2VJbnQoZGlnaXRzLnN1YnN0cihpLCBuKSwgMTApLCBuICogMyArIDEsIGJiKTtcbiAgICAgICAgaSArPSBuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBfUXJTZWdtZW50KF9RclNlZ21lbnQuTW9kZS5OVU1FUklDLCBkaWdpdHMubGVuZ3RoLCBiYik7XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlQWxwaGFudW1lcmljKHRleHQpIHtcbiAgICAgIGlmICghX1FyU2VnbWVudC5pc0FscGhhbnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTdHJpbmcgY29udGFpbnMgdW5lbmNvZGFibGUgY2hhcmFjdGVycyBpbiBhbHBoYW51bWVyaWMgbW9kZVwiKTtcbiAgICAgIGxldCBiYiA9IFtdO1xuICAgICAgbGV0IGk7XG4gICAgICBmb3IgKGkgPSAwOyBpICsgMiA8PSB0ZXh0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGxldCB0ZW1wID0gX1FyU2VnbWVudC5BTFBIQU5VTUVSSUNfQ0hBUlNFVC5pbmRleE9mKHRleHQuY2hhckF0KGkpKSAqIDQ1O1xuICAgICAgICB0ZW1wICs9IF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpICsgMSkpO1xuICAgICAgICBhcHBlbmRCaXRzKHRlbXAsIDExLCBiYik7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IHRleHQubGVuZ3RoKVxuICAgICAgICBhcHBlbmRCaXRzKF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX0NIQVJTRVQuaW5kZXhPZih0ZXh0LmNoYXJBdChpKSksIDYsIGJiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuQUxQSEFOVU1FUklDLCB0ZXh0Lmxlbmd0aCwgYmIpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZVNlZ21lbnRzKHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09IFwiXCIpXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGVsc2UgaWYgKF9RclNlZ21lbnQuaXNOdW1lcmljKHRleHQpKVxuICAgICAgICByZXR1cm4gW19RclNlZ21lbnQubWFrZU51bWVyaWModGV4dCldO1xuICAgICAgZWxzZSBpZiAoX1FyU2VnbWVudC5pc0FscGhhbnVtZXJpYyh0ZXh0KSlcbiAgICAgICAgcmV0dXJuIFtfUXJTZWdtZW50Lm1ha2VBbHBoYW51bWVyaWModGV4dCldO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gW19RclNlZ21lbnQubWFrZUJ5dGVzKF9RclNlZ21lbnQudG9VdGY4Qnl0ZUFycmF5KHRleHQpKV07XG4gICAgfVxuICAgIHN0YXRpYyBtYWtlRWNpKGFzc2lnblZhbCkge1xuICAgICAgbGV0IGJiID0gW107XG4gICAgICBpZiAoYXNzaWduVmFsIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFQ0kgYXNzaWdubWVudCB2YWx1ZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBlbHNlIGlmIChhc3NpZ25WYWwgPCAxIDw8IDcpXG4gICAgICAgIGFwcGVuZEJpdHMoYXNzaWduVmFsLCA4LCBiYik7XG4gICAgICBlbHNlIGlmIChhc3NpZ25WYWwgPCAxIDw8IDE0KSB7XG4gICAgICAgIGFwcGVuZEJpdHMoMiwgMiwgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgMTQsIGJiKTtcbiAgICAgIH0gZWxzZSBpZiAoYXNzaWduVmFsIDwgMWU2KSB7XG4gICAgICAgIGFwcGVuZEJpdHMoNiwgMywgYmIpO1xuICAgICAgICBhcHBlbmRCaXRzKGFzc2lnblZhbCwgMjEsIGJiKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVDSSBhc3NpZ25tZW50IHZhbHVlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgIHJldHVybiBuZXcgX1FyU2VnbWVudChfUXJTZWdtZW50Lk1vZGUuRUNJLCAwLCBiYik7XG4gICAgfVxuICAgIHN0YXRpYyBpc051bWVyaWModGV4dCkge1xuICAgICAgcmV0dXJuIF9RclNlZ21lbnQuTlVNRVJJQ19SRUdFWC50ZXN0KHRleHQpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNBbHBoYW51bWVyaWModGV4dCkge1xuICAgICAgcmV0dXJuIF9RclNlZ21lbnQuQUxQSEFOVU1FUklDX1JFR0VYLnRlc3QodGV4dCk7XG4gICAgfVxuICAgIGdldERhdGEoKSB7XG4gICAgICByZXR1cm4gdGhpcy5iaXREYXRhLnNsaWNlKCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRUb3RhbEJpdHMoc2VncywgdmVyc2lvbikge1xuICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGNvbnN0IGNjYml0cyA9IHNlZy5tb2RlLm51bUNoYXJDb3VudEJpdHModmVyc2lvbik7XG4gICAgICAgIGlmIChzZWcubnVtQ2hhcnMgPj0gMSA8PCBjY2JpdHMpXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICByZXN1bHQgKz0gNCArIGNjYml0cyArIHNlZy5iaXREYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyB0b1V0ZjhCeXRlQXJyYXkoc3RyKSB7XG4gICAgICBzdHIgPSBlbmNvZGVVUkkoc3RyKTtcbiAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHIuY2hhckF0KGkpICE9IFwiJVwiKVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc3RyLnN1YnN0cihpICsgMSwgMiksIDE2KSk7XG4gICAgICAgICAgaSArPSAyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbiAgbGV0IFFyU2VnbWVudCA9IF9RclNlZ21lbnQ7XG4gIFFyU2VnbWVudC5OVU1FUklDX1JFR0VYID0gL15bMC05XSokLztcbiAgUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19SRUdFWCA9IC9eW0EtWjAtOSAkJSorLlxcLzotXSokLztcbiAgUXJTZWdtZW50LkFMUEhBTlVNRVJJQ19DSEFSU0VUID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVogJCUqKy0uLzpcIjtcbiAgcXJjb2RlZ2VuMi5RclNlZ21lbnQgPSBRclNlZ21lbnQ7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG4oKHFyY29kZWdlbjIpID0+IHtcbiAgbGV0IFFyQ29kZTtcbiAgKChRckNvZGUyKSA9PiB7XG4gICAgY29uc3QgX0VjYyA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG9yZGluYWwsIGZvcm1hdEJpdHMpIHtcbiAgICAgICAgdGhpcy5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICAgICAgdGhpcy5mb3JtYXRCaXRzID0gZm9ybWF0Qml0cztcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBFY2MgPSBfRWNjO1xuICAgIEVjYy5MT1cgPSBuZXcgX0VjYygwLCAxKTtcbiAgICBFY2MuTUVESVVNID0gbmV3IF9FY2MoMSwgMCk7XG4gICAgRWNjLlFVQVJUSUxFID0gbmV3IF9FY2MoMiwgMyk7XG4gICAgRWNjLkhJR0ggPSBuZXcgX0VjYygzLCAyKTtcbiAgICBRckNvZGUyLkVjYyA9IEVjYztcbiAgfSkoUXJDb2RlID0gcXJjb2RlZ2VuMi5RckNvZGUgfHwgKHFyY29kZWdlbjIuUXJDb2RlID0ge30pKTtcbn0pKHFyY29kZWdlbiB8fCAocXJjb2RlZ2VuID0ge30pKTtcbigocXJjb2RlZ2VuMikgPT4ge1xuICBsZXQgUXJTZWdtZW50O1xuICAoKFFyU2VnbWVudDIpID0+IHtcbiAgICBjb25zdCBfTW9kZSA9IGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKG1vZGVCaXRzLCBudW1CaXRzQ2hhckNvdW50KSB7XG4gICAgICAgIHRoaXMubW9kZUJpdHMgPSBtb2RlQml0cztcbiAgICAgICAgdGhpcy5udW1CaXRzQ2hhckNvdW50ID0gbnVtQml0c0NoYXJDb3VudDtcbiAgICAgIH1cbiAgICAgIG51bUNoYXJDb3VudEJpdHModmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bUJpdHNDaGFyQ291bnRbTWF0aC5mbG9vcigodmVyICsgNykgLyAxNyldO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IE1vZGUgPSBfTW9kZTtcbiAgICBNb2RlLk5VTUVSSUMgPSBuZXcgX01vZGUoMSwgWzEwLCAxMiwgMTRdKTtcbiAgICBNb2RlLkFMUEhBTlVNRVJJQyA9IG5ldyBfTW9kZSgyLCBbOSwgMTEsIDEzXSk7XG4gICAgTW9kZS5CWVRFID0gbmV3IF9Nb2RlKDQsIFs4LCAxNiwgMTZdKTtcbiAgICBNb2RlLktBTkpJID0gbmV3IF9Nb2RlKDgsIFs4LCAxMCwgMTJdKTtcbiAgICBNb2RlLkVDSSA9IG5ldyBfTW9kZSg3LCBbMCwgMCwgMF0pO1xuICAgIFFyU2VnbWVudDIuTW9kZSA9IE1vZGU7XG4gIH0pKFFyU2VnbWVudCA9IHFyY29kZWdlbjIuUXJTZWdtZW50IHx8IChxcmNvZGVnZW4yLlFyU2VnbWVudCA9IHt9KSk7XG59KShxcmNvZGVnZW4gfHwgKHFyY29kZWdlbiA9IHt9KSk7XG52YXIgcXJjb2RlZ2VuX2RlZmF1bHQgPSBxcmNvZGVnZW47XG5cbi8vIHNyYy9pbmRleC50c3hcbi8qKlxuICogQGxpY2Vuc2UgcXJjb2RlLnJlYWN0XG4gKiBDb3B5cmlnaHQgKGMpIFBhdWwgTydTaGFubmVzc3lcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBJU0NcbiAqL1xudmFyIEVSUk9SX0xFVkVMX01BUCA9IHtcbiAgTDogcXJjb2RlZ2VuX2RlZmF1bHQuUXJDb2RlLkVjYy5MT1csXG4gIE06IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5FY2MuTUVESVVNLFxuICBROiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLlFVQVJUSUxFLFxuICBIOiBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuRWNjLkhJR0hcbn07XG52YXIgREVGQVVMVF9TSVpFID0gMTI4O1xudmFyIERFRkFVTFRfTEVWRUwgPSBcIkxcIjtcbnZhciBERUZBVUxUX0JHQ09MT1IgPSBcIiNGRkZGRkZcIjtcbnZhciBERUZBVUxUX0ZHQ09MT1IgPSBcIiMwMDAwMDBcIjtcbnZhciBERUZBVUxUX0lOQ0xVREVNQVJHSU4gPSBmYWxzZTtcbnZhciBNQVJHSU5fU0laRSA9IDQ7XG52YXIgREVGQVVMVF9JTUdfU0NBTEUgPSAwLjE7XG5mdW5jdGlvbiBnZW5lcmF0ZVBhdGgobW9kdWxlcywgbWFyZ2luID0gMCkge1xuICBjb25zdCBvcHMgPSBbXTtcbiAgbW9kdWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJvdywgeSkge1xuICAgIGxldCBzdGFydCA9IG51bGw7XG4gICAgcm93LmZvckVhY2goZnVuY3Rpb24oY2VsbCwgeCkge1xuICAgICAgaWYgKCFjZWxsICYmIHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgIG9wcy5wdXNoKGBNJHtzdGFydCArIG1hcmdpbn0gJHt5ICsgbWFyZ2lufWgke3ggLSBzdGFydH12MUgke3N0YXJ0ICsgbWFyZ2lufXpgKTtcbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoeCA9PT0gcm93Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgIG9wcy5wdXNoKGBNJHt4ICsgbWFyZ2lufSwke3kgKyBtYXJnaW59IGgxdjFIJHt4ICsgbWFyZ2lufXpgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHMucHVzaChgTSR7c3RhcnQgKyBtYXJnaW59LCR7eSArIG1hcmdpbn0gaCR7eCArIDEgLSBzdGFydH12MUgke3N0YXJ0ICsgbWFyZ2lufXpgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2VsbCAmJiBzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICBzdGFydCA9IHg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb3BzLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBleGNhdmF0ZU1vZHVsZXMobW9kdWxlcywgZXhjYXZhdGlvbikge1xuICByZXR1cm4gbW9kdWxlcy5zbGljZSgpLm1hcCgocm93LCB5KSA9PiB7XG4gICAgaWYgKHkgPCBleGNhdmF0aW9uLnkgfHwgeSA+PSBleGNhdmF0aW9uLnkgKyBleGNhdmF0aW9uLmgpIHtcbiAgICAgIHJldHVybiByb3c7XG4gICAgfVxuICAgIHJldHVybiByb3cubWFwKChjZWxsLCB4KSA9PiB7XG4gICAgICBpZiAoeCA8IGV4Y2F2YXRpb24ueCB8fCB4ID49IGV4Y2F2YXRpb24ueCArIGV4Y2F2YXRpb24udykge1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRJbWFnZVNldHRpbmdzKGNlbGxzLCBzaXplLCBpbmNsdWRlTWFyZ2luLCBpbWFnZVNldHRpbmdzKSB7XG4gIGlmIChpbWFnZVNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICBjb25zdCBudW1DZWxscyA9IGNlbGxzLmxlbmd0aCArIG1hcmdpbiAqIDI7XG4gIGNvbnN0IGRlZmF1bHRTaXplID0gTWF0aC5mbG9vcihzaXplICogREVGQVVMVF9JTUdfU0NBTEUpO1xuICBjb25zdCBzY2FsZSA9IG51bUNlbGxzIC8gc2l6ZTtcbiAgY29uc3QgdyA9IChpbWFnZVNldHRpbmdzLndpZHRoIHx8IGRlZmF1bHRTaXplKSAqIHNjYWxlO1xuICBjb25zdCBoID0gKGltYWdlU2V0dGluZ3MuaGVpZ2h0IHx8IGRlZmF1bHRTaXplKSAqIHNjYWxlO1xuICBjb25zdCB4ID0gaW1hZ2VTZXR0aW5ncy54ID09IG51bGwgPyBjZWxscy5sZW5ndGggLyAyIC0gdyAvIDIgOiBpbWFnZVNldHRpbmdzLnggKiBzY2FsZTtcbiAgY29uc3QgeSA9IGltYWdlU2V0dGluZ3MueSA9PSBudWxsID8gY2VsbHMubGVuZ3RoIC8gMiAtIGggLyAyIDogaW1hZ2VTZXR0aW5ncy55ICogc2NhbGU7XG4gIGxldCBleGNhdmF0aW9uID0gbnVsbDtcbiAgaWYgKGltYWdlU2V0dGluZ3MuZXhjYXZhdGUpIHtcbiAgICBsZXQgZmxvb3JYID0gTWF0aC5mbG9vcih4KTtcbiAgICBsZXQgZmxvb3JZID0gTWF0aC5mbG9vcih5KTtcbiAgICBsZXQgY2VpbFcgPSBNYXRoLmNlaWwodyArIHggLSBmbG9vclgpO1xuICAgIGxldCBjZWlsSCA9IE1hdGguY2VpbChoICsgeSAtIGZsb29yWSk7XG4gICAgZXhjYXZhdGlvbiA9IHsgeDogZmxvb3JYLCB5OiBmbG9vclksIHc6IGNlaWxXLCBoOiBjZWlsSCB9O1xuICB9XG4gIHJldHVybiB7IHgsIHksIGgsIHcsIGV4Y2F2YXRpb24gfTtcbn1cbnZhciBTVVBQT1JUU19QQVRIMkQgPSBmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBuZXcgUGF0aDJEKCkuYWRkUGF0aChuZXcgUGF0aDJEKCkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufSgpO1xuZnVuY3Rpb24gUVJDb2RlQ2FudmFzKHByb3BzKSB7XG4gIGNvbnN0IF9hID0gcHJvcHMsIHtcbiAgICB2YWx1ZSxcbiAgICBzaXplID0gREVGQVVMVF9TSVpFLFxuICAgIGxldmVsID0gREVGQVVMVF9MRVZFTCxcbiAgICBiZ0NvbG9yID0gREVGQVVMVF9CR0NPTE9SLFxuICAgIGZnQ29sb3IgPSBERUZBVUxUX0ZHQ09MT1IsXG4gICAgaW5jbHVkZU1hcmdpbiA9IERFRkFVTFRfSU5DTFVERU1BUkdJTixcbiAgICBzdHlsZSxcbiAgICBpbWFnZVNldHRpbmdzXG4gIH0gPSBfYSwgb3RoZXJQcm9wcyA9IF9fb2JqUmVzdChfYSwgW1xuICAgIFwidmFsdWVcIixcbiAgICBcInNpemVcIixcbiAgICBcImxldmVsXCIsXG4gICAgXCJiZ0NvbG9yXCIsXG4gICAgXCJmZ0NvbG9yXCIsXG4gICAgXCJpbmNsdWRlTWFyZ2luXCIsXG4gICAgXCJzdHlsZVwiLFxuICAgIFwiaW1hZ2VTZXR0aW5nc1wiXG4gIF0pO1xuICBjb25zdCBpbWdTcmMgPSBpbWFnZVNldHRpbmdzID09IG51bGwgPyB2b2lkIDAgOiBpbWFnZVNldHRpbmdzLnNyYztcbiAgY29uc3QgX2NhbnZhcyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgX2ltYWdlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBbaXNJbWdMb2FkZWQsIHNldElzSW1hZ2VMb2FkZWRdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChfY2FudmFzLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgY2FudmFzID0gX2NhbnZhcy5jdXJyZW50O1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBjZWxscyA9IHFyY29kZWdlbl9kZWZhdWx0LlFyQ29kZS5lbmNvZGVUZXh0KHZhbHVlLCBFUlJPUl9MRVZFTF9NQVBbbGV2ZWxdKS5nZXRNb2R1bGVzKCk7XG4gICAgICBjb25zdCBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICAgICAgY29uc3QgbnVtQ2VsbHMgPSBjZWxscy5sZW5ndGggKyBtYXJnaW4gKiAyO1xuICAgICAgY29uc3QgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgPSBnZXRJbWFnZVNldHRpbmdzKGNlbGxzLCBzaXplLCBpbmNsdWRlTWFyZ2luLCBpbWFnZVNldHRpbmdzKTtcbiAgICAgIGNvbnN0IGltYWdlID0gX2ltYWdlLmN1cnJlbnQ7XG4gICAgICBjb25zdCBoYXZlSW1hZ2VUb1JlbmRlciA9IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzICE9IG51bGwgJiYgaW1hZ2UgIT09IG51bGwgJiYgaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbEhlaWdodCAhPT0gMCAmJiBpbWFnZS5uYXR1cmFsV2lkdGggIT09IDA7XG4gICAgICBpZiAoaGF2ZUltYWdlVG9SZW5kZXIpIHtcbiAgICAgICAgaWYgKGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIGNlbGxzID0gZXhjYXZhdGVNb2R1bGVzKGNlbGxzLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoID0gc2l6ZSAqIHBpeGVsUmF0aW87XG4gICAgICBjb25zdCBzY2FsZSA9IHNpemUgLyBudW1DZWxscyAqIHBpeGVsUmF0aW87XG4gICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIG51bUNlbGxzLCBudW1DZWxscyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgIGlmIChTVVBQT1JUU19QQVRIMkQpIHtcbiAgICAgICAgY3R4LmZpbGwobmV3IFBhdGgyRChnZW5lcmF0ZVBhdGgoY2VsbHMsIG1hcmdpbikpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGxzLmZvckVhY2goZnVuY3Rpb24ocm93LCByZHgpIHtcbiAgICAgICAgICByb3cuZm9yRWFjaChmdW5jdGlvbihjZWxsLCBjZHgpIHtcbiAgICAgICAgICAgIGlmIChjZWxsKSB7XG4gICAgICAgICAgICAgIGN0eC5maWxsUmVjdChjZHggKyBtYXJnaW4sIHJkeCArIG1hcmdpbiwgMSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGhhdmVJbWFnZVRvUmVuZGVyKSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnggKyBtYXJnaW4sIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnkgKyBtYXJnaW4sIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLncsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNJbWFnZUxvYWRlZChmYWxzZSk7XG4gIH0sIFtpbWdTcmNdKTtcbiAgY29uc3QgY2FudmFzU3R5bGUgPSBfX3NwcmVhZFZhbHVlcyh7IGhlaWdodDogc2l6ZSwgd2lkdGg6IHNpemUgfSwgc3R5bGUpO1xuICBsZXQgaW1nID0gbnVsbDtcbiAgaWYgKGltZ1NyYyAhPSBudWxsKSB7XG4gICAgaW1nID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgICAgc3JjOiBpbWdTcmMsXG4gICAgICBrZXk6IGltZ1NyYyxcbiAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0sXG4gICAgICBvbkxvYWQ6ICgpID0+IHtcbiAgICAgICAgc2V0SXNJbWFnZUxvYWRlZCh0cnVlKTtcbiAgICAgIH0sXG4gICAgICByZWY6IF9pbWFnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwgX19zcHJlYWRWYWx1ZXMoe1xuICAgIHN0eWxlOiBjYW52YXNTdHlsZSxcbiAgICBoZWlnaHQ6IHNpemUsXG4gICAgd2lkdGg6IHNpemUsXG4gICAgcmVmOiBfY2FudmFzXG4gIH0sIG90aGVyUHJvcHMpKSwgaW1nKTtcbn1cbmZ1bmN0aW9uIFFSQ29kZVNWRyhwcm9wcykge1xuICBjb25zdCBfYSA9IHByb3BzLCB7XG4gICAgdmFsdWUsXG4gICAgc2l6ZSA9IERFRkFVTFRfU0laRSxcbiAgICBsZXZlbCA9IERFRkFVTFRfTEVWRUwsXG4gICAgYmdDb2xvciA9IERFRkFVTFRfQkdDT0xPUixcbiAgICBmZ0NvbG9yID0gREVGQVVMVF9GR0NPTE9SLFxuICAgIGluY2x1ZGVNYXJnaW4gPSBERUZBVUxUX0lOQ0xVREVNQVJHSU4sXG4gICAgaW1hZ2VTZXR0aW5nc1xuICB9ID0gX2EsIG90aGVyUHJvcHMgPSBfX29ialJlc3QoX2EsIFtcbiAgICBcInZhbHVlXCIsXG4gICAgXCJzaXplXCIsXG4gICAgXCJsZXZlbFwiLFxuICAgIFwiYmdDb2xvclwiLFxuICAgIFwiZmdDb2xvclwiLFxuICAgIFwiaW5jbHVkZU1hcmdpblwiLFxuICAgIFwiaW1hZ2VTZXR0aW5nc1wiXG4gIF0pO1xuICBsZXQgY2VsbHMgPSBxcmNvZGVnZW5fZGVmYXVsdC5RckNvZGUuZW5jb2RlVGV4dCh2YWx1ZSwgRVJST1JfTEVWRUxfTUFQW2xldmVsXSkuZ2V0TW9kdWxlcygpO1xuICBjb25zdCBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICBjb25zdCBudW1DZWxscyA9IGNlbGxzLmxlbmd0aCArIG1hcmdpbiAqIDI7XG4gIGNvbnN0IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzID0gZ2V0SW1hZ2VTZXR0aW5ncyhjZWxscywgc2l6ZSwgaW5jbHVkZU1hcmdpbiwgaW1hZ2VTZXR0aW5ncyk7XG4gIGxldCBpbWFnZSA9IG51bGw7XG4gIGlmIChpbWFnZVNldHRpbmdzICE9IG51bGwgJiYgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MgIT0gbnVsbCkge1xuICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uICE9IG51bGwpIHtcbiAgICAgIGNlbGxzID0gZXhjYXZhdGVNb2R1bGVzKGNlbGxzLCBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uKTtcbiAgICB9XG4gICAgaW1hZ2UgPSAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcImltYWdlXCIsIHtcbiAgICAgIHhsaW5rSHJlZjogaW1hZ2VTZXR0aW5ncy5zcmMsXG4gICAgICBoZWlnaHQ6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmgsXG4gICAgICB3aWR0aDogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MudyxcbiAgICAgIHg6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLnggKyBtYXJnaW4sXG4gICAgICB5OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy55ICsgbWFyZ2luLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogXCJub25lXCJcbiAgICB9KTtcbiAgfVxuICBjb25zdCBmZ1BhdGggPSBnZW5lcmF0ZVBhdGgoY2VsbHMsIG1hcmdpbik7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCBfX3NwcmVhZFZhbHVlcyh7XG4gICAgaGVpZ2h0OiBzaXplLFxuICAgIHdpZHRoOiBzaXplLFxuICAgIHZpZXdCb3g6IGAwIDAgJHtudW1DZWxsc30gJHtudW1DZWxsc31gXG4gIH0sIG90aGVyUHJvcHMpLCAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGZpbGw6IGJnQ29sb3IsXG4gICAgZDogYE0wLDAgaCR7bnVtQ2VsbHN9diR7bnVtQ2VsbHN9SDB6YCxcbiAgICBzaGFwZVJlbmRlcmluZzogXCJjcmlzcEVkZ2VzXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgZmlsbDogZmdDb2xvcixcbiAgICBkOiBmZ1BhdGgsXG4gICAgc2hhcGVSZW5kZXJpbmc6IFwiY3Jpc3BFZGdlc1wiXG4gIH0pLCBpbWFnZSk7XG59XG52YXIgUVJDb2RlID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IF9hID0gcHJvcHMsIHsgcmVuZGVyQXMgfSA9IF9hLCBvdGhlclByb3BzID0gX19vYmpSZXN0KF9hLCBbXCJyZW5kZXJBc1wiXSk7XG4gIGlmIChyZW5kZXJBcyA9PT0gXCJzdmdcIikge1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gUmVhY3QuY3JlYXRlRWxlbWVudChRUkNvZGVTVkcsIF9fc3ByZWFkVmFsdWVzKHt9LCBvdGhlclByb3BzKSk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFFSQ29kZUNhbnZhcywgX19zcHJlYWRWYWx1ZXMoe30sIG90aGVyUHJvcHMpKTtcbn07XG5leHBvcnQge1xuICBRUkNvZGVDYW52YXMsXG4gIFFSQ29kZVNWRyxcbiAgUVJDb2RlIGFzIGRlZmF1bHRcbn07XG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2dldE93blByb3BTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX3Byb3BJc0VudW0iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIl9fZGVmTm9ybWFsUHJvcCIsIm9iaiIsImtleSIsInZhbHVlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiX19zcHJlYWRWYWx1ZXMiLCJhIiwiYiIsInByb3AiLCJjYWxsIiwiX19vYmpSZXN0Iiwic291cmNlIiwiZXhjbHVkZSIsInRhcmdldCIsImluZGV4T2YiLCJSZWFjdCIsInFyY29kZWdlbiIsInFyY29kZWdlbjIiLCJfUXJDb2RlIiwiY29uc3RydWN0b3IiLCJ2ZXJzaW9uIiwiZXJyb3JDb3JyZWN0aW9uTGV2ZWwiLCJkYXRhQ29kZXdvcmRzIiwibXNrIiwibW9kdWxlcyIsImlzRnVuY3Rpb24iLCJNSU5fVkVSU0lPTiIsIk1BWF9WRVJTSU9OIiwiUmFuZ2VFcnJvciIsInNpemUiLCJyb3ciLCJpIiwicHVzaCIsInNsaWNlIiwiZHJhd0Z1bmN0aW9uUGF0dGVybnMiLCJhbGxDb2Rld29yZHMiLCJhZGRFY2NBbmRJbnRlcmxlYXZlIiwiZHJhd0NvZGV3b3JkcyIsIm1pblBlbmFsdHkiLCJhcHBseU1hc2siLCJkcmF3Rm9ybWF0Qml0cyIsInBlbmFsdHkiLCJnZXRQZW5hbHR5U2NvcmUiLCJhc3NlcnQiLCJtYXNrIiwiZW5jb2RlVGV4dCIsInRleHQiLCJlY2wiLCJzZWdzIiwiUXJTZWdtZW50IiwibWFrZVNlZ21lbnRzIiwiZW5jb2RlU2VnbWVudHMiLCJlbmNvZGVCaW5hcnkiLCJkYXRhIiwic2VnIiwibWFrZUJ5dGVzIiwibWluVmVyc2lvbiIsIm1heFZlcnNpb24iLCJib29zdEVjbCIsImRhdGFVc2VkQml0cyIsImRhdGFDYXBhY2l0eUJpdHMyIiwiZ2V0TnVtRGF0YUNvZGV3b3JkcyIsInVzZWRCaXRzIiwiZ2V0VG90YWxCaXRzIiwibmV3RWNsIiwiRWNjIiwiTUVESVVNIiwiUVVBUlRJTEUiLCJISUdIIiwiYmIiLCJhcHBlbmRCaXRzIiwibW9kZSIsIm1vZGVCaXRzIiwibnVtQ2hhcnMiLCJudW1DaGFyQ291bnRCaXRzIiwiZ2V0RGF0YSIsImxlbmd0aCIsImRhdGFDYXBhY2l0eUJpdHMiLCJNYXRoIiwibWluIiwicGFkQnl0ZSIsImZvckVhY2giLCJnZXRNb2R1bGUiLCJ4IiwieSIsImdldE1vZHVsZXMiLCJzZXRGdW5jdGlvbk1vZHVsZSIsImRyYXdGaW5kZXJQYXR0ZXJuIiwiYWxpZ25QYXRQb3MiLCJnZXRBbGlnbm1lbnRQYXR0ZXJuUG9zaXRpb25zIiwibnVtQWxpZ24iLCJqIiwiZHJhd0FsaWdubWVudFBhdHRlcm4iLCJkcmF3VmVyc2lvbiIsImZvcm1hdEJpdHMiLCJyZW0iLCJiaXRzIiwiZ2V0Qml0IiwiY29sb3IiLCJmbG9vciIsImR5IiwiZHgiLCJkaXN0IiwibWF4IiwiYWJzIiwieHgiLCJ5eSIsImlzRGFyayIsInZlciIsIm51bUJsb2NrcyIsIk5VTV9FUlJPUl9DT1JSRUNUSU9OX0JMT0NLUyIsIm9yZGluYWwiLCJibG9ja0VjY0xlbiIsIkVDQ19DT0RFV09SRFNfUEVSX0JMT0NLIiwicmF3Q29kZXdvcmRzIiwiZ2V0TnVtUmF3RGF0YU1vZHVsZXMiLCJudW1TaG9ydEJsb2NrcyIsInNob3J0QmxvY2tMZW4iLCJibG9ja3MiLCJyc0RpdiIsInJlZWRTb2xvbW9uQ29tcHV0ZURpdmlzb3IiLCJrIiwiZGF0IiwiZWNjIiwicmVlZFNvbG9tb25Db21wdXRlUmVtYWluZGVyIiwiY29uY2F0IiwicmVzdWx0IiwiYmxvY2siLCJyaWdodCIsInZlcnQiLCJ1cHdhcmQiLCJpbnZlcnQiLCJFcnJvciIsInJ1bkNvbG9yIiwicnVuWCIsInJ1bkhpc3RvcnkiLCJQRU5BTFRZX04xIiwiZmluZGVyUGVuYWx0eUFkZEhpc3RvcnkiLCJmaW5kZXJQZW5hbHR5Q291bnRQYXR0ZXJucyIsIlBFTkFMVFlfTjMiLCJmaW5kZXJQZW5hbHR5VGVybWluYXRlQW5kQ291bnQiLCJydW5ZIiwiUEVOQUxUWV9OMiIsImRhcmsiLCJyZWR1Y2UiLCJzdW0iLCJ0b3RhbCIsImNlaWwiLCJQRU5BTFRZX040Iiwic3RlcCIsInBvcyIsInNwbGljZSIsImRlZ3JlZSIsInJvb3QiLCJyZWVkU29sb21vbk11bHRpcGx5IiwiZGl2aXNvciIsIm1hcCIsIl8iLCJmYWN0b3IiLCJzaGlmdCIsImNvZWYiLCJ6IiwibiIsImNvcmUiLCJjdXJyZW50UnVuQ29sb3IiLCJjdXJyZW50UnVuTGVuZ3RoIiwicG9wIiwidW5zaGlmdCIsIlFyQ29kZSIsInZhbCIsImxlbiIsImNvbmQiLCJfUXJTZWdtZW50IiwiYml0RGF0YSIsIk1vZGUiLCJCWVRFIiwibWFrZU51bWVyaWMiLCJkaWdpdHMiLCJpc051bWVyaWMiLCJwYXJzZUludCIsInN1YnN0ciIsIk5VTUVSSUMiLCJtYWtlQWxwaGFudW1lcmljIiwiaXNBbHBoYW51bWVyaWMiLCJ0ZW1wIiwiQUxQSEFOVU1FUklDX0NIQVJTRVQiLCJjaGFyQXQiLCJBTFBIQU5VTUVSSUMiLCJ0b1V0ZjhCeXRlQXJyYXkiLCJtYWtlRWNpIiwiYXNzaWduVmFsIiwiRUNJIiwiTlVNRVJJQ19SRUdFWCIsInRlc3QiLCJBTFBIQU5VTUVSSUNfUkVHRVgiLCJjY2JpdHMiLCJJbmZpbml0eSIsInN0ciIsImVuY29kZVVSSSIsImNoYXJDb2RlQXQiLCJRckNvZGUyIiwiX0VjYyIsIkxPVyIsIlFyU2VnbWVudDIiLCJfTW9kZSIsIm51bUJpdHNDaGFyQ291bnQiLCJLQU5KSSIsInFyY29kZWdlbl9kZWZhdWx0IiwiRVJST1JfTEVWRUxfTUFQIiwiTCIsIk0iLCJRIiwiSCIsIkRFRkFVTFRfU0laRSIsIkRFRkFVTFRfTEVWRUwiLCJERUZBVUxUX0JHQ09MT1IiLCJERUZBVUxUX0ZHQ09MT1IiLCJERUZBVUxUX0lOQ0xVREVNQVJHSU4iLCJNQVJHSU5fU0laRSIsIkRFRkFVTFRfSU1HX1NDQUxFIiwiZ2VuZXJhdGVQYXRoIiwibWFyZ2luIiwib3BzIiwic3RhcnQiLCJjZWxsIiwiam9pbiIsImV4Y2F2YXRlTW9kdWxlcyIsImV4Y2F2YXRpb24iLCJoIiwidyIsImdldEltYWdlU2V0dGluZ3MiLCJjZWxscyIsImluY2x1ZGVNYXJnaW4iLCJpbWFnZVNldHRpbmdzIiwibnVtQ2VsbHMiLCJkZWZhdWx0U2l6ZSIsInNjYWxlIiwid2lkdGgiLCJoZWlnaHQiLCJleGNhdmF0ZSIsImZsb29yWCIsImZsb29yWSIsImNlaWxXIiwiY2VpbEgiLCJTVVBQT1JUU19QQVRIMkQiLCJQYXRoMkQiLCJhZGRQYXRoIiwiZSIsIlFSQ29kZUNhbnZhcyIsInByb3BzIiwiX2EiLCJsZXZlbCIsImJnQ29sb3IiLCJmZ0NvbG9yIiwic3R5bGUiLCJvdGhlclByb3BzIiwiaW1nU3JjIiwic3JjIiwiX2NhbnZhcyIsInVzZVJlZiIsIl9pbWFnZSIsImlzSW1nTG9hZGVkIiwic2V0SXNJbWFnZUxvYWRlZCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyIsImltYWdlIiwiaGF2ZUltYWdlVG9SZW5kZXIiLCJjb21wbGV0ZSIsIm5hdHVyYWxIZWlnaHQiLCJuYXR1cmFsV2lkdGgiLCJwaXhlbFJhdGlvIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZmlsbCIsInJkeCIsImNkeCIsImRyYXdJbWFnZSIsImNhbnZhc1N0eWxlIiwiaW1nIiwiY3JlYXRlRWxlbWVudCIsImRpc3BsYXkiLCJvbkxvYWQiLCJyZWYiLCJGcmFnbWVudCIsIlFSQ29kZVNWRyIsInhsaW5rSHJlZiIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJmZ1BhdGgiLCJ2aWV3Qm94IiwiZCIsInNoYXBlUmVuZGVyaW5nIiwiUVJDb2RlIiwicmVuZGVyQXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/qrcode.react@3.2.0_react@18.3.1/node_modules/qrcode.react/lib/esm/index.js\n");

/***/ })

};
;