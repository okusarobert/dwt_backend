"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/trading/page",{

/***/ "(app-pages-browser)/./lib/api-client.ts":
/*!***************************!*\
  !*** ./lib/api-client.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; }\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/.pnpm/axios@1.11.0/node_modules/axios/lib/axios.js\");\n/* harmony import */ var _cookie_auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cookie-auth */ \"(app-pages-browser)/./lib/cookie-auth.ts\");\n\n\nclass ApiClient {\n    setupInterceptors() {\n        // Add auth header interceptor\n        this.authClient.interceptors.request.use(async (config)=>{\n            // For HTTP-only cookies, we don't need to manually add headers\n            // The browser will automatically include cookies\n            return config;\n        }, (error)=>{\n            return Promise.reject(error);\n        });\n        // Reuse same interceptors for admin client if ever separated\n        this.walletClient.interceptors.request.use(async (config)=>{\n            // For HTTP-only cookies, we don't need to manually add headers\n            // The browser will automatically include cookies\n            return config;\n        }, (error)=>{\n            return Promise.reject(error);\n        });\n        // Handle response errors\n        this.authClient.interceptors.response.use((response)=>response, async (error)=>{\n            var _error_response;\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401) {\n                // Clear auth state on 401\n                await _cookie_auth__WEBPACK_IMPORTED_MODULE_0__.cookieAuth.removeAuthCookie();\n            }\n            return Promise.reject(error);\n        });\n        this.walletClient.interceptors.response.use((response)=>response, async (error)=>{\n            var _error_response;\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 401) {\n                // Clear auth state on 401\n                await _cookie_auth__WEBPACK_IMPORTED_MODULE_0__.cookieAuth.removeAuthCookie();\n            }\n            return Promise.reject(error);\n        });\n    }\n    async login(credentials) {\n        const response = await this.authClient.post(\"/login\", credentials);\n        return response.data;\n    }\n    async register(userData) {\n        try {\n            const response = await this.authClient.post(\"/register\", userData);\n            // Backend returns {\"message\": \"User registered successfully\"} with status 201\n            // We need to handle this response format\n            if (response.status === 201) {\n                return {\n                    message: response.data.message || \"User registered successfully\",\n                    user: undefined\n                };\n            }\n            return response.data;\n        } catch (error) {\n            var _error_response, _error_response1;\n            console.error(\"Registration failed:\", error);\n            // Handle different error status codes\n            if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 400) {\n                var _error_response2;\n                // Validation errors or bad request\n                if (((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.data) && typeof error.response.data === \"object\") {\n                    throw new Error(JSON.stringify(error.response.data));\n                }\n                throw new Error(\"Invalid registration data\");\n            } else if (((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) === 500) {\n                // Internal server error\n                throw new Error(\"Internal server error. Please try again later.\");\n            } else {\n                // Other errors\n                throw new Error(\"Registration failed. Please try again.\");\n            }\n        }\n    }\n    async logout() {\n        try {\n            await this.authClient.post(\"/logout\");\n            await _cookie_auth__WEBPACK_IMPORTED_MODULE_0__.cookieAuth.removeAuthCookie();\n            return true;\n        } catch (error) {\n            console.error(\"Logout failed:\", error);\n            return false;\n        }\n    }\n    async isAuthenticated() {\n        return await _cookie_auth__WEBPACK_IMPORTED_MODULE_0__.cookieAuth.isAuthenticated();\n    }\n    async getCurrentUser() {\n        try {\n            const decodedToken = await _cookie_auth__WEBPACK_IMPORTED_MODULE_0__.cookieAuth.getDecodedToken();\n            if (decodedToken) {\n                // Return basic user info from token\n                return {\n                    id: decodedToken.user_id,\n                    email: \"\",\n                    first_name: \"\",\n                    last_name: \"\",\n                    role: \"user\"\n                };\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Failed to get current user:\", error);\n            return null;\n        }\n    }\n    async getUserConfig() {\n        try {\n            const response = await this.authClient.get(\"/user-config\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to get user config:\", error);\n            return null;\n        }\n    }\n    // Wallet-specific methods\n    async getDashboardSummary() {\n        const response = await this.walletClient.get(\"/wallet/dashboard/summary\");\n        return response.data;\n    }\n    async getWalletBalance() {\n        const response = await this.walletClient.get(\"/wallet/balance\");\n        return response.data;\n    }\n    async getTransactionHistory() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5, offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        const response = await this.walletClient.get(\"/wallet/transactions\", {\n            params: {\n                limit,\n                offset\n            }\n        });\n        return response.data;\n    }\n    // ------------------------------\n    // Admin: Users\n    // ------------------------------\n    async adminListUsers(params) {\n        // Map UI params to backend params\n        const mapped = {\n            ...params || {}\n        };\n        if (mapped.q) {\n            mapped.email = mapped.q;\n            delete mapped.q;\n        }\n        if (mapped.role) {\n            mapped.role = String(mapped.role).toUpperCase();\n        }\n        const response = await this.adminClient.get(\"/admin/users\", {\n            params: mapped\n        });\n        const data = response.data || {};\n        const items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n        var _params_page;\n        const page = typeof (data === null || data === void 0 ? void 0 : data.page) === \"number\" ? data.page : (_params_page = params === null || params === void 0 ? void 0 : params.page) !== null && _params_page !== void 0 ? _params_page : 1;\n        var _params_page_size, _ref;\n        const page_size = typeof (data === null || data === void 0 ? void 0 : data.page_size) === \"number\" ? data.page_size : (_ref = (_params_page_size = params === null || params === void 0 ? void 0 : params.page_size) !== null && _params_page_size !== void 0 ? _params_page_size : items.length) !== null && _ref !== void 0 ? _ref : 0;\n        const total = typeof (data === null || data === void 0 ? void 0 : data.total) === \"number\" ? data.total : Array.isArray(items) ? items.length : 0;\n        return {\n            success: true,\n            data: items,\n            pagination: {\n                page,\n                page_size,\n                total\n            }\n        };\n    }\n    async adminGetUser(userId) {\n        const response = await this.adminClient.get(\"/admin/users/\".concat(userId));\n        return {\n            success: true,\n            data: response.data\n        };\n    }\n    async adminUpdateUser(userId, patch) {\n        const body = {\n            ...patch || {}\n        };\n        if (body.default_currency) {\n            body.currency = body.default_currency;\n            delete body.default_currency;\n        }\n        if (body.role) {\n            body.role = String(body.role).toUpperCase();\n        }\n        const response = await this.adminClient.patch(\"/admin/users/\".concat(userId), body);\n        return {\n            success: true,\n            data: response.data\n        };\n    }\n    // ===== PORTFOLIO ENDPOINTS =====\n    /**\n   * Get portfolio summary for the authenticated user\n   */ async getPortfolioSummary() {\n        try {\n            const response = await this.walletClient.get(\"/wallet/portfolio/summary\");\n            return response.data;\n        } catch (error) {\n            console.error(\"Error fetching portfolio summary:\", error);\n            throw error;\n        }\n    }\n    // =============================\n    async getReserveStatus() {\n        const response = await this.walletClient.get(\"/wallet/reserves/status\");\n        const data = response.data;\n        const reserves = data === null || data === void 0 ? void 0 : data.reserves;\n        // Always normalize to simple array shape for the UI\n        const items = [];\n        if (Array.isArray(reserves)) {\n            // Backend already returns array; coerce account entries\n            for (const entry of reserves){\n                var _entry_currency;\n                const currency = String((_entry_currency = entry === null || entry === void 0 ? void 0 : entry.currency) !== null && _entry_currency !== void 0 ? _entry_currency : \"\");\n                const accs = Array.isArray(entry === null || entry === void 0 ? void 0 : entry.accounts) ? entry.accounts : [];\n                const simpleAccs = accs.map((acc)=>{\n                    const i = acc || {};\n                    var _i_account_type, _ref;\n                    const account_type = String((_ref = (_i_account_type = i.account_type) !== null && _i_account_type !== void 0 ? _i_account_type : i.type) !== null && _ref !== void 0 ? _ref : \"\").toUpperCase();\n                    const balance = typeof i.total_balance === \"number\" ? i.total_balance : typeof i.available_balance === \"number\" ? i.available_balance : typeof i.balance === \"number\" ? i.balance : 0;\n                    const available = typeof i.available_balance === \"number\" ? i.available_balance : undefined;\n                    const locked = typeof i.locked_balance === \"number\" ? i.locked_balance : undefined;\n                    return {\n                        account_type,\n                        balance,\n                        available,\n                        locked\n                    };\n                });\n                items.push({\n                    currency,\n                    accounts: simpleAccs\n                });\n            }\n        } else {\n            // Normalize from grouped object shape { crypto: {CUR: info}, fiat: {CUR: info} }\n            const pushFromGroup = (group, accountType)=>{\n                if (!group || typeof group !== \"object\") return;\n                Object.entries(group).forEach((param)=>{\n                    let [currency, info] = param;\n                    const i = info || {};\n                    const balance = typeof i.total_balance === \"number\" ? i.total_balance : typeof i.available_balance === \"number\" ? i.available_balance : typeof i.balance === \"number\" ? i.balance : 0;\n                    const available = typeof i.available_balance === \"number\" ? i.available_balance : undefined;\n                    const locked = typeof i.locked_balance === \"number\" ? i.locked_balance : undefined;\n                    let item = items.find((x)=>x.currency === currency);\n                    if (!item) {\n                        item = {\n                            currency,\n                            accounts: []\n                        };\n                        items.push(item);\n                    }\n                    item.accounts.push({\n                        account_type: accountType,\n                        balance,\n                        available,\n                        locked\n                    });\n                });\n            };\n            pushFromGroup(reserves === null || reserves === void 0 ? void 0 : reserves.crypto, \"CRYPTO\");\n            pushFromGroup(reserves === null || reserves === void 0 ? void 0 : reserves.fiat, \"FIAT\");\n        }\n        var _data_success;\n        return {\n            success: (_data_success = data === null || data === void 0 ? void 0 : data.success) !== null && _data_success !== void 0 ? _data_success : true,\n            reserves: items\n        };\n    }\n    async getReserveBalance(currency, accountType) {\n        const response = await this.walletClient.get(\"/wallet/reserves/\".concat(currency, \"/\").concat(accountType, \"/balance\"));\n        const data = response.data || {};\n        const b = data.balance;\n        let numeric = 0;\n        if (typeof b === \"number\") {\n            numeric = b;\n        } else if (b && typeof b === \"object\") {\n            const i = b;\n            if (typeof i.total_balance === \"number\") numeric = i.total_balance;\n            else if (typeof i.available_balance === \"number\") numeric = i.available_balance;\n            else if (typeof i.balance === \"number\") numeric = i.balance;\n        }\n        return {\n            success: Boolean(data.success),\n            balance: numeric\n        };\n    }\n    async topUpReserve(currency, accountType, amount, source_reference) {\n        const response = await this.walletClient.post(\"/wallet/reserves/\".concat(currency, \"/\").concat(accountType, \"/topup\"), {\n            amount,\n            source_reference\n        });\n        return response.data;\n    }\n    async withdrawFromReserve(currency, accountType, amount, destination_reference) {\n        const response = await this.walletClient.post(\"/wallet/reserves/\".concat(currency, \"/\").concat(accountType, \"/withdraw\"), {\n            amount,\n            destination_reference\n        });\n        return response.data;\n    }\n    async getReserveAnalytics() {\n        let period_days = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 30;\n        const response = await this.walletClient.get(\"/wallet/reserves/analytics\", {\n            params: {\n                period_days\n            }\n        });\n        return response.data;\n    }\n    async clearReserveCache() {\n        const response = await this.walletClient.post(\"/wallet/reserves/cache/clear\");\n        return response.data;\n    }\n    // Trading endpoints\n    async calculateTrade(tradeType, cryptoCurrency, amount) {\n        const response = await this.walletClient.post(\"/api/trading/\".concat(tradeType, \"/calculate\"), {\n            crypto_currency: cryptoCurrency,\n            amount: amount\n        });\n        return response.data;\n    }\n    async executeTrade(tradeType, cryptoCurrency, amount, phoneNumber) {\n        const response = await this.walletClient.post(\"/api/trading/\".concat(tradeType), {\n            crypto_currency: cryptoCurrency,\n            amount: amount,\n            phone_number: phoneNumber\n        });\n        return response.data;\n    }\n    async getTradeHistory() {\n        let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 50, offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        const response = await this.walletClient.get(\"/api/trading/history\", {\n            params: {\n                limit,\n                offset\n            }\n        });\n        return response.data;\n    }\n    constructor(){\n        // Auth service client\n        this.authClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n            baseURL: \"\".concat(\"http://localhost:3030\", \"/api/v1\"),\n            withCredentials: true,\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        // Wallet service client\n        this.walletClient = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n            baseURL: \"\".concat(\"http://localhost:3030\", \"/api/v1\"),\n            withCredentials: true,\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        // Admin routes share same base; endpoints start with /admin\n        this.adminClient = this.walletClient;\n        this.setupInterceptors();\n    }\n}\nconst apiClient = new ApiClient();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXVDLE9BQXBDQyx1QkFBbUMsRUFBQztZQUNoREcsaUJBQWlCO1lBQ2pCQyxTQUFTO2dCQUNQLGdCQUFnQjtZQUNsQjtRQUNGO1FBRUEsNERBQTREO1FBQzVELElBQUksQ0FBQzNFLFdBQVcsR0FBRyxJQUFJLENBQUN6QyxZQUFZO1FBRXBDLElBQUksQ0FBQ1QsaUJBQWlCO0lBQ3hCO0FBMFpGO0FBRU8sTUFBTThILFlBQVksSUFBSS9ILFlBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2FwaS1jbGllbnQudHM/YjA5OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MsIHsgQXhpb3NJbnN0YW5jZSwgQXhpb3NSZXNwb25zZSB9IGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IHsgY29va2llQXV0aCB9IGZyb20gXCIuL2Nvb2tpZS1hdXRoXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBudW1iZXI7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGZpcnN0X25hbWU6IHN0cmluZztcbiAgbGFzdF9uYW1lOiBzdHJpbmc7XG4gIHJvbGU6IHN0cmluZztcbiAgY291bnRyeT86IHN0cmluZztcbiAgcGhvbmVfbnVtYmVyPzogc3RyaW5nO1xuICByZWZfY29kZT86IHN0cmluZztcbiAgY3JlYXRlZF9hdD86IHN0cmluZztcbiAgYmFsYW5jZT86IG51bWJlcjtcbiAgY3VycmVuY3k/OiBzdHJpbmc7XG4gIGxvY2tlZF9hbW91bnQ/OiBudW1iZXI7XG4gIG1heF9kZXBvc2l0PzogbnVtYmVyO1xuICBtaW5fZGVwb3NpdD86IG51bWJlcjtcbiAgLy8gQWRtaW4gZmxhZ3MgKG9wdGlvbmFsIG9uIG1hbnkgZW5kcG9pbnRzKVxuICBibG9ja2VkPzogYm9vbGVhbjtcbiAgZGVsZXRlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aFJlc3BvbnNlIHtcbiAgbWVzc2FnZT86IHN0cmluZztcbiAgdXNlcj86IFVzZXI7XG4gIHRva2VuPzogc3RyaW5nO1xuICAvLyBGb3IgcmVnaXN0cmF0aW9uLCBiYWNrZW5kIHJldHVybnMge1wibWVzc2FnZVwiOiBcIlVzZXIgcmVnaXN0ZXJlZCBzdWNjZXNzZnVsbHlcIn1cbiAgLy8gRm9yIGxvZ2luLCBiYWNrZW5kIHJldHVybnMgdXNlciBkYXRhXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9naW5SZXF1ZXN0IHtcbiAgZW1haWw6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RlclJlcXVlc3Qge1xuICBlbWFpbDogc3RyaW5nO1xuICBwaG9uZV9udW1iZXI6IHN0cmluZztcbiAgZmlyc3RfbmFtZTogc3RyaW5nO1xuICBsYXN0X25hbWU6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgcGFzc3dvcmRfY29uZmlybTogc3RyaW5nO1xuICBzcG9uc29yX2NvZGU/OiBzdHJpbmc7XG4gIGNvdW50cnk/OiBzdHJpbmc7XG59XG5cbmNsYXNzIEFwaUNsaWVudCB7XG4gIHByaXZhdGUgYXV0aENsaWVudDogQXhpb3NJbnN0YW5jZTtcbiAgcHJpdmF0ZSB3YWxsZXRDbGllbnQ6IEF4aW9zSW5zdGFuY2U7XG4gIHByaXZhdGUgYWRtaW5DbGllbnQ6IEF4aW9zSW5zdGFuY2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gQXV0aCBzZXJ2aWNlIGNsaWVudFxuICAgIHRoaXMuYXV0aENsaWVudCA9IGF4aW9zLmNyZWF0ZSh7XG4gICAgICBiYXNlVVJMOiBgJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQUNLRU5EX1VSTH0vYXBpL3YxYCxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gV2FsbGV0IHNlcnZpY2UgY2xpZW50XG4gICAgdGhpcy53YWxsZXRDbGllbnQgPSBheGlvcy5jcmVhdGUoe1xuICAgICAgYmFzZVVSTDogYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkx9L2FwaS92MWAsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIEFkbWluIHJvdXRlcyBzaGFyZSBzYW1lIGJhc2U7IGVuZHBvaW50cyBzdGFydCB3aXRoIC9hZG1pblxuICAgIHRoaXMuYWRtaW5DbGllbnQgPSB0aGlzLndhbGxldENsaWVudDtcblxuICAgIHRoaXMuc2V0dXBJbnRlcmNlcHRvcnMoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBJbnRlcmNlcHRvcnMoKSB7XG4gICAgLy8gQWRkIGF1dGggaGVhZGVyIGludGVyY2VwdG9yXG4gICAgdGhpcy5hdXRoQ2xpZW50LmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShcbiAgICAgIGFzeW5jIChjb25maWcpID0+IHtcbiAgICAgICAgLy8gRm9yIEhUVFAtb25seSBjb29raWVzLCB3ZSBkb24ndCBuZWVkIHRvIG1hbnVhbGx5IGFkZCBoZWFkZXJzXG4gICAgICAgIC8vIFRoZSBicm93c2VyIHdpbGwgYXV0b21hdGljYWxseSBpbmNsdWRlIGNvb2tpZXNcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH0sXG4gICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUmV1c2Ugc2FtZSBpbnRlcmNlcHRvcnMgZm9yIGFkbWluIGNsaWVudCBpZiBldmVyIHNlcGFyYXRlZFxuXG4gICAgdGhpcy53YWxsZXRDbGllbnQuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKFxuICAgICAgYXN5bmMgKGNvbmZpZykgPT4ge1xuICAgICAgICAvLyBGb3IgSFRUUC1vbmx5IGNvb2tpZXMsIHdlIGRvbid0IG5lZWQgdG8gbWFudWFsbHkgYWRkIGhlYWRlcnNcbiAgICAgICAgLy8gVGhlIGJyb3dzZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGluY2x1ZGUgY29va2llc1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgIH0sXG4gICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gSGFuZGxlIHJlc3BvbnNlIGVycm9yc1xuICAgIHRoaXMuYXV0aENsaWVudC5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKFxuICAgICAgKHJlc3BvbnNlKSA9PiByZXNwb25zZSxcbiAgICAgIGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgIC8vIENsZWFyIGF1dGggc3RhdGUgb24gNDAxXG4gICAgICAgICAgYXdhaXQgY29va2llQXV0aC5yZW1vdmVBdXRoQ29va2llKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy53YWxsZXRDbGllbnQuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShcbiAgICAgIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXG4gICAgICBhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgIC8vIENsZWFyIGF1dGggc3RhdGUgb24gNDAxXG4gICAgICAgICAgYXdhaXQgY29va2llQXV0aC5yZW1vdmVBdXRoQ29va2llKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBhc3luYyBsb2dpbihjcmVkZW50aWFsczogTG9naW5SZXF1ZXN0KTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+IHtcbiAgICBjb25zdCByZXNwb25zZTogQXhpb3NSZXNwb25zZTxBdXRoUmVzcG9uc2U+ID0gYXdhaXQgdGhpcy5hdXRoQ2xpZW50LnBvc3QoXG4gICAgICBcIi9sb2dpblwiLFxuICAgICAgY3JlZGVudGlhbHNcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG5cbiAgYXN5bmMgcmVnaXN0ZXIodXNlckRhdGE6IFJlZ2lzdGVyUmVxdWVzdCk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlOiBBeGlvc1Jlc3BvbnNlPEF1dGhSZXNwb25zZT4gPSBhd2FpdCB0aGlzLmF1dGhDbGllbnQucG9zdChcbiAgICAgICAgXCIvcmVnaXN0ZXJcIixcbiAgICAgICAgdXNlckRhdGFcbiAgICAgICk7XG5cbiAgICAgIC8vIEJhY2tlbmQgcmV0dXJucyB7XCJtZXNzYWdlXCI6IFwiVXNlciByZWdpc3RlcmVkIHN1Y2Nlc3NmdWxseVwifSB3aXRoIHN0YXR1cyAyMDFcbiAgICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIHRoaXMgcmVzcG9uc2UgZm9ybWF0XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5kYXRhLm1lc3NhZ2UgfHwgXCJVc2VyIHJlZ2lzdGVyZWQgc3VjY2Vzc2Z1bGx5XCIsXG4gICAgICAgICAgdXNlcjogdW5kZWZpbmVkLCAvLyBObyB1c2VyIGRhdGEgcmV0dXJuZWQgb24gcmVnaXN0cmF0aW9uXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUmVnaXN0cmF0aW9uIGZhaWxlZDpcIiwgZXJyb3IpO1xuXG4gICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IGVycm9yIHN0YXR1cyBjb2Rlc1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwMCkge1xuICAgICAgICAvLyBWYWxpZGF0aW9uIGVycm9ycyBvciBiYWQgcmVxdWVzdFxuICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGEgJiYgdHlwZW9mIGVycm9yLnJlc3BvbnNlLmRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmVnaXN0cmF0aW9uIGRhdGFcIik7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAvLyBJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyIGVycm9yc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWdpc3RyYXRpb24gZmFpbGVkLiBQbGVhc2UgdHJ5IGFnYWluLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBsb2dvdXQoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuYXV0aENsaWVudC5wb3N0KFwiL2xvZ291dFwiKTtcbiAgICAgIGF3YWl0IGNvb2tpZUF1dGgucmVtb3ZlQXV0aENvb2tpZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJMb2dvdXQgZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgaXNBdXRoZW50aWNhdGVkKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBhd2FpdCBjb29raWVBdXRoLmlzQXV0aGVudGljYXRlZCgpO1xuICB9XG5cbiAgYXN5bmMgZ2V0Q3VycmVudFVzZXIoKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNvZGVkVG9rZW4gPSBhd2FpdCBjb29raWVBdXRoLmdldERlY29kZWRUb2tlbigpO1xuICAgICAgaWYgKGRlY29kZWRUb2tlbikge1xuICAgICAgICAvLyBSZXR1cm4gYmFzaWMgdXNlciBpbmZvIGZyb20gdG9rZW5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogZGVjb2RlZFRva2VuLnVzZXJfaWQsXG4gICAgICAgICAgZW1haWw6IFwiXCIsIC8vIE5vdCBhdmFpbGFibGUgaW4gdG9rZW5cbiAgICAgICAgICBmaXJzdF9uYW1lOiBcIlwiLCAvLyBOb3QgYXZhaWxhYmxlIGluIHRva2VuXG4gICAgICAgICAgbGFzdF9uYW1lOiBcIlwiLCAvLyBOb3QgYXZhaWxhYmxlIGluIHRva2VuXG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsIC8vIERlZmF1bHQgcm9sZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgdXNlcjpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2V0VXNlckNvbmZpZygpOiBQcm9taXNlPHsgdXNlcjogVXNlciB9IHwgbnVsbD4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZTogQXhpb3NSZXNwb25zZTx7IHVzZXI6IFVzZXIgfT4gPSBhd2FpdCB0aGlzLmF1dGhDbGllbnQuZ2V0KFxuICAgICAgICBcIi91c2VyLWNvbmZpZ1wiXG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBnZXQgdXNlciBjb25maWc6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdhbGxldC1zcGVjaWZpYyBtZXRob2RzXG4gIGFzeW5jIGdldERhc2hib2FyZFN1bW1hcnkoKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LmdldChcIi93YWxsZXQvZGFzaGJvYXJkL3N1bW1hcnlcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cblxuICBhc3luYyBnZXRXYWxsZXRCYWxhbmNlKCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldENsaWVudC5nZXQoXCIvd2FsbGV0L2JhbGFuY2VcIik7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cblxuICBhc3luYyBnZXRUcmFuc2FjdGlvbkhpc3RvcnkobGltaXQgPSA1LCBvZmZzZXQgPSAwKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LmdldChcIi93YWxsZXQvdHJhbnNhY3Rpb25zXCIsIHtcbiAgICAgIHBhcmFtczogeyBsaW1pdCwgb2Zmc2V0IH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQWRtaW46IFVzZXJzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBhc3luYyBhZG1pbkxpc3RVc2VycyhwYXJhbXM/OiB7XG4gICAgcT86IHN0cmluZztcbiAgICByb2xlPzogc3RyaW5nO1xuICAgIGJsb2NrZWQ/OiBib29sZWFuO1xuICAgIGRlbGV0ZWQ/OiBib29sZWFuO1xuICAgIHBhZ2U/OiBudW1iZXI7XG4gICAgcGFnZV9zaXplPzogbnVtYmVyO1xuICB9KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGRhdGE6IFVzZXJbXTsgcGFnaW5hdGlvbjogeyBwYWdlOiBudW1iZXI7IHBhZ2Vfc2l6ZTogbnVtYmVyOyB0b3RhbDogbnVtYmVyIH0gfT4ge1xuICAgIC8vIE1hcCBVSSBwYXJhbXMgdG8gYmFja2VuZCBwYXJhbXNcbiAgICBjb25zdCBtYXBwZWQ6IGFueSA9IHsgLi4uKHBhcmFtcyB8fCB7fSkgfTtcbiAgICBpZiAobWFwcGVkLnEpIHtcbiAgICAgIG1hcHBlZC5lbWFpbCA9IG1hcHBlZC5xO1xuICAgICAgZGVsZXRlIG1hcHBlZC5xO1xuICAgIH1cbiAgICBpZiAobWFwcGVkLnJvbGUpIHtcbiAgICAgIG1hcHBlZC5yb2xlID0gU3RyaW5nKG1hcHBlZC5yb2xlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hZG1pbkNsaWVudC5nZXQoXCIvYWRtaW4vdXNlcnNcIiwgeyBwYXJhbXM6IG1hcHBlZCB9KTtcbiAgICBjb25zdCBkYXRhOiBhbnkgPSByZXNwb25zZS5kYXRhIHx8IHt9O1xuICAgIGNvbnN0IGl0ZW1zOiBVc2VyW10gPSBBcnJheS5pc0FycmF5KGRhdGE/Lml0ZW1zKSA/IGRhdGEuaXRlbXMgOiBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFtdO1xuICAgIGNvbnN0IHBhZ2UgPSB0eXBlb2YgZGF0YT8ucGFnZSA9PT0gXCJudW1iZXJcIiA/IGRhdGEucGFnZSA6IChwYXJhbXM/LnBhZ2UgPz8gMSk7XG4gICAgY29uc3QgcGFnZV9zaXplID0gdHlwZW9mIGRhdGE/LnBhZ2Vfc2l6ZSA9PT0gXCJudW1iZXJcIiA/IGRhdGEucGFnZV9zaXplIDogKHBhcmFtcz8ucGFnZV9zaXplID8/IGl0ZW1zLmxlbmd0aCA/PyAwKTtcbiAgICBjb25zdCB0b3RhbCA9IHR5cGVvZiBkYXRhPy50b3RhbCA9PT0gXCJudW1iZXJcIiA/IGRhdGEudG90YWwgOiAoQXJyYXkuaXNBcnJheShpdGVtcykgPyBpdGVtcy5sZW5ndGggOiAwKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBpdGVtcywgcGFnaW5hdGlvbjogeyBwYWdlLCBwYWdlX3NpemUsIHRvdGFsIH0gfTtcbiAgfVxuXG4gIGFzeW5jIGFkbWluR2V0VXNlcih1c2VySWQ6IG51bWJlcik6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBkYXRhOiBVc2VyIH0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWRtaW5DbGllbnQuZ2V0KGAvYWRtaW4vdXNlcnMvJHt1c2VySWR9YCk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzcG9uc2UuZGF0YSB9O1xuICB9XG5cbiAgYXN5bmMgYWRtaW5VcGRhdGVVc2VyKHVzZXJJZDogbnVtYmVyLCBwYXRjaDogUGFydGlhbDxQaWNrPFVzZXIsXG4gICAgfCBcImZpcnN0X25hbWVcIlxuICAgIHwgXCJsYXN0X25hbWVcIlxuICAgIHwgXCJwaG9uZV9udW1iZXJcIlxuICAgIHwgXCJyb2xlXCJcbiAgICB8IFwiY291bnRyeVwiXG4gICAgfCBcInJlZl9jb2RlXCJcbiAgPj4gJiB7IGJsb2NrZWQ/OiBib29sZWFuOyBkZWxldGVkPzogYm9vbGVhbjsgZGVmYXVsdF9jdXJyZW5jeT86IHN0cmluZyB9KTogUHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IGRhdGE6IFVzZXIgfT4ge1xuICAgIGNvbnN0IGJvZHk6IGFueSA9IHsgLi4uKHBhdGNoIHx8IHt9KSB9O1xuICAgIGlmIChib2R5LmRlZmF1bHRfY3VycmVuY3kpIHtcbiAgICAgIGJvZHkuY3VycmVuY3kgPSBib2R5LmRlZmF1bHRfY3VycmVuY3k7XG4gICAgICBkZWxldGUgYm9keS5kZWZhdWx0X2N1cnJlbmN5O1xuICAgIH1cbiAgICBpZiAoYm9keS5yb2xlKSB7XG4gICAgICBib2R5LnJvbGUgPSBTdHJpbmcoYm9keS5yb2xlKS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYWRtaW5DbGllbnQucGF0Y2goYC9hZG1pbi91c2Vycy8ke3VzZXJJZH1gLCBib2R5KTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXNwb25zZS5kYXRhIH07XG4gIH1cblxuICAvLyA9PT09PSBQT1JURk9MSU8gRU5EUE9JTlRTID09PT09XG4gIFxuICAvKipcbiAgICogR2V0IHBvcnRmb2xpbyBzdW1tYXJ5IGZvciB0aGUgYXV0aGVudGljYXRlZCB1c2VyXG4gICAqL1xuICBhc3luYyBnZXRQb3J0Zm9saW9TdW1tYXJ5KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LmdldCgnL3dhbGxldC9wb3J0Zm9saW8vc3VtbWFyeScpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHBvcnRmb2xpbyBzdW1tYXJ5OicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGFzeW5jIGdldFJlc2VydmVTdGF0dXMoKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LmdldChcIi93YWxsZXQvcmVzZXJ2ZXMvc3RhdHVzXCIpO1xuICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgIGNvbnN0IHJlc2VydmVzID0gZGF0YT8ucmVzZXJ2ZXM7XG5cbiAgICAvLyBBbHdheXMgbm9ybWFsaXplIHRvIHNpbXBsZSBhcnJheSBzaGFwZSBmb3IgdGhlIFVJXG4gICAgY29uc3QgaXRlbXM6IEFycmF5PHtcbiAgICAgIGN1cnJlbmN5OiBzdHJpbmc7XG4gICAgICBhY2NvdW50czogQXJyYXk8eyBhY2NvdW50X3R5cGU6IHN0cmluZzsgYmFsYW5jZTogbnVtYmVyOyBhdmFpbGFibGU/OiBudW1iZXI7IGxvY2tlZD86IG51bWJlciB9PjtcbiAgICB9PiA9IFtdO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzZXJ2ZXMpKSB7XG4gICAgICAvLyBCYWNrZW5kIGFscmVhZHkgcmV0dXJucyBhcnJheTsgY29lcmNlIGFjY291bnQgZW50cmllc1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiByZXNlcnZlcykge1xuICAgICAgICBjb25zdCBjdXJyZW5jeSA9IFN0cmluZygoZW50cnkgYXMgYW55KT8uY3VycmVuY3kgPz8gXCJcIik7XG4gICAgICAgIGNvbnN0IGFjY3M6IGFueVtdID0gQXJyYXkuaXNBcnJheSgoZW50cnkgYXMgYW55KT8uYWNjb3VudHMpID8gKGVudHJ5IGFzIGFueSkuYWNjb3VudHMgOiBbXTtcbiAgICAgICAgY29uc3Qgc2ltcGxlQWNjcyA9IGFjY3MubWFwKChhY2MpID0+IHtcbiAgICAgICAgICBjb25zdCBpOiBhbnkgPSBhY2MgfHwge307XG4gICAgICAgICAgY29uc3QgYWNjb3VudF90eXBlID0gU3RyaW5nKChpLmFjY291bnRfdHlwZSA/PyBpLnR5cGUgPz8gXCJcIikpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgY29uc3QgYmFsYW5jZSA9XG4gICAgICAgICAgICB0eXBlb2YgaS50b3RhbF9iYWxhbmNlID09PSBcIm51bWJlclwiID8gaS50b3RhbF9iYWxhbmNlIDpcbiAgICAgICAgICAgIHR5cGVvZiBpLmF2YWlsYWJsZV9iYWxhbmNlID09PSBcIm51bWJlclwiID8gaS5hdmFpbGFibGVfYmFsYW5jZSA6XG4gICAgICAgICAgICB0eXBlb2YgaS5iYWxhbmNlID09PSBcIm51bWJlclwiID8gaS5iYWxhbmNlIDogMDtcbiAgICAgICAgICBjb25zdCBhdmFpbGFibGUgPSB0eXBlb2YgaS5hdmFpbGFibGVfYmFsYW5jZSA9PT0gXCJudW1iZXJcIiA/IGkuYXZhaWxhYmxlX2JhbGFuY2UgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgY29uc3QgbG9ja2VkID0gdHlwZW9mIGkubG9ja2VkX2JhbGFuY2UgPT09IFwibnVtYmVyXCIgPyBpLmxvY2tlZF9iYWxhbmNlIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHJldHVybiB7IGFjY291bnRfdHlwZSwgYmFsYW5jZSwgYXZhaWxhYmxlLCBsb2NrZWQgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZW1zLnB1c2goeyBjdXJyZW5jeSwgYWNjb3VudHM6IHNpbXBsZUFjY3MgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSBmcm9tIGdyb3VwZWQgb2JqZWN0IHNoYXBlIHsgY3J5cHRvOiB7Q1VSOiBpbmZvfSwgZmlhdDoge0NVUjogaW5mb30gfVxuICAgICAgY29uc3QgcHVzaEZyb21Hcm91cCA9IChncm91cDogYW55LCBhY2NvdW50VHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICghZ3JvdXAgfHwgdHlwZW9mIGdyb3VwICE9PSBcIm9iamVjdFwiKSByZXR1cm47XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGdyb3VwKS5mb3JFYWNoKChbY3VycmVuY3ksIGluZm9dKSA9PiB7XG4gICAgICAgICAgY29uc3QgaTogYW55ID0gaW5mbyB8fCB7fTtcbiAgICAgICAgICBjb25zdCBiYWxhbmNlID1cbiAgICAgICAgICAgIHR5cGVvZiBpLnRvdGFsX2JhbGFuY2UgPT09IFwibnVtYmVyXCIgPyBpLnRvdGFsX2JhbGFuY2UgOlxuICAgICAgICAgICAgdHlwZW9mIGkuYXZhaWxhYmxlX2JhbGFuY2UgPT09IFwibnVtYmVyXCIgPyBpLmF2YWlsYWJsZV9iYWxhbmNlIDpcbiAgICAgICAgICAgIHR5cGVvZiBpLmJhbGFuY2UgPT09IFwibnVtYmVyXCIgPyBpLmJhbGFuY2UgOiAwO1xuICAgICAgICAgIGNvbnN0IGF2YWlsYWJsZSA9IHR5cGVvZiBpLmF2YWlsYWJsZV9iYWxhbmNlID09PSBcIm51bWJlclwiID8gaS5hdmFpbGFibGVfYmFsYW5jZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCBsb2NrZWQgPSB0eXBlb2YgaS5sb2NrZWRfYmFsYW5jZSA9PT0gXCJudW1iZXJcIiA/IGkubG9ja2VkX2JhbGFuY2UgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBsZXQgaXRlbSA9IGl0ZW1zLmZpbmQoKHgpID0+IHguY3VycmVuY3kgPT09IGN1cnJlbmN5KTtcbiAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0gPSB7IGN1cnJlbmN5LCBhY2NvdW50czogW10gfTtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0uYWNjb3VudHMucHVzaCh7IGFjY291bnRfdHlwZTogYWNjb3VudFR5cGUsIGJhbGFuY2UsIGF2YWlsYWJsZSwgbG9ja2VkIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHB1c2hGcm9tR3JvdXAocmVzZXJ2ZXM/LmNyeXB0bywgXCJDUllQVE9cIik7XG4gICAgICBwdXNoRnJvbUdyb3VwKHJlc2VydmVzPy5maWF0LCBcIkZJQVRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc3VjY2VzczogZGF0YT8uc3VjY2VzcyA/PyB0cnVlLCByZXNlcnZlczogaXRlbXMgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFJlc2VydmVCYWxhbmNlKFxuICAgIGN1cnJlbmN5OiBzdHJpbmcsXG4gICAgYWNjb3VudFR5cGU6IHN0cmluZ1xuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXRDbGllbnQuZ2V0KFxuICAgICAgYC93YWxsZXQvcmVzZXJ2ZXMvJHtjdXJyZW5jeX0vJHthY2NvdW50VHlwZX0vYmFsYW5jZWBcbiAgICApO1xuICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhIHx8IHt9O1xuICAgIGNvbnN0IGIgPSAoZGF0YSBhcyBhbnkpLmJhbGFuY2U7XG4gICAgbGV0IG51bWVyaWMgPSAwO1xuICAgIGlmICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbnVtZXJpYyA9IGI7XG4gICAgfSBlbHNlIGlmIChiICYmIHR5cGVvZiBiID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBpOiBhbnkgPSBiO1xuICAgICAgaWYgKHR5cGVvZiBpLnRvdGFsX2JhbGFuY2UgPT09IFwibnVtYmVyXCIpIG51bWVyaWMgPSBpLnRvdGFsX2JhbGFuY2U7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgaS5hdmFpbGFibGVfYmFsYW5jZSA9PT0gXCJudW1iZXJcIikgbnVtZXJpYyA9IGkuYXZhaWxhYmxlX2JhbGFuY2U7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgaS5iYWxhbmNlID09PSBcIm51bWJlclwiKSBudW1lcmljID0gaS5iYWxhbmNlO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBCb29sZWFuKChkYXRhIGFzIGFueSkuc3VjY2VzcyksIGJhbGFuY2U6IG51bWVyaWMgfTtcbiAgfVxuXG4gIGFzeW5jIHRvcFVwUmVzZXJ2ZShcbiAgICBjdXJyZW5jeTogc3RyaW5nLFxuICAgIGFjY291bnRUeXBlOiBzdHJpbmcsXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICAgc291cmNlX3JlZmVyZW5jZT86IHN0cmluZ1xuICApOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXRDbGllbnQucG9zdChcbiAgICAgIGAvd2FsbGV0L3Jlc2VydmVzLyR7Y3VycmVuY3l9LyR7YWNjb3VudFR5cGV9L3RvcHVwYCxcbiAgICAgIHsgYW1vdW50LCBzb3VyY2VfcmVmZXJlbmNlIH1cbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG5cbiAgYXN5bmMgd2l0aGRyYXdGcm9tUmVzZXJ2ZShcbiAgICBjdXJyZW5jeTogc3RyaW5nLFxuICAgIGFjY291bnRUeXBlOiBzdHJpbmcsXG4gICAgYW1vdW50OiBudW1iZXIsXG4gICAgZGVzdGluYXRpb25fcmVmZXJlbmNlPzogc3RyaW5nXG4gICk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldENsaWVudC5wb3N0KFxuICAgICAgYC93YWxsZXQvcmVzZXJ2ZXMvJHtjdXJyZW5jeX0vJHthY2NvdW50VHlwZX0vd2l0aGRyYXdgLFxuICAgICAgeyBhbW91bnQsIGRlc3RpbmF0aW9uX3JlZmVyZW5jZSB9XG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuXG4gIGFzeW5jIGdldFJlc2VydmVBbmFseXRpY3MocGVyaW9kX2RheXMgPSAzMCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldENsaWVudC5nZXQoXG4gICAgICBgL3dhbGxldC9yZXNlcnZlcy9hbmFseXRpY3NgLFxuICAgICAgeyBwYXJhbXM6IHsgcGVyaW9kX2RheXMgfSB9XG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxuXG4gIGFzeW5jIGNsZWFyUmVzZXJ2ZUNhY2hlKCk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLndhbGxldENsaWVudC5wb3N0KFxuICAgICAgXCIvd2FsbGV0L3Jlc2VydmVzL2NhY2hlL2NsZWFyXCJcbiAgICApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG5cbiAgLy8gVHJhZGluZyBlbmRwb2ludHNcbiAgYXN5bmMgY2FsY3VsYXRlVHJhZGUoXG4gICAgdHJhZGVUeXBlOiAnYnV5JyB8ICdzZWxsJyxcbiAgICBjcnlwdG9DdXJyZW5jeTogc3RyaW5nLFxuICAgIGFtb3VudDogbnVtYmVyXG4gICk6IFByb21pc2U8e1xuICAgIGNyeXB0b19hbW91bnQ6IG51bWJlcjtcbiAgICBmaWF0X2Ftb3VudDogbnVtYmVyO1xuICAgIGV4Y2hhbmdlX3JhdGU6IG51bWJlcjtcbiAgICBmZWVfYW1vdW50OiBudW1iZXI7XG4gICAgdG90YWxfY29zdD86IG51bWJlcjtcbiAgICBuZXRfcHJvY2VlZHM/OiBudW1iZXI7XG4gIH0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LnBvc3QoYC9hcGkvdHJhZGluZy8ke3RyYWRlVHlwZX0vY2FsY3VsYXRlYCwge1xuICAgICAgY3J5cHRvX2N1cnJlbmN5OiBjcnlwdG9DdXJyZW5jeSxcbiAgICAgIGFtb3VudDogYW1vdW50XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cblxuICBhc3luYyBleGVjdXRlVHJhZGUoXG4gICAgdHJhZGVUeXBlOiAnYnV5JyB8ICdzZWxsJyxcbiAgICBjcnlwdG9DdXJyZW5jeTogc3RyaW5nLFxuICAgIGFtb3VudDogbnVtYmVyLFxuICAgIHBob25lTnVtYmVyOiBzdHJpbmdcbiAgKTogUHJvbWlzZTx7XG4gICAgdHJhZGVfaWQ6IHN0cmluZztcbiAgICBzdGF0dXM6IHN0cmluZztcbiAgICBwYXltZW50X3VybD86IHN0cmluZztcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gIH0+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMud2FsbGV0Q2xpZW50LnBvc3QoYC9hcGkvdHJhZGluZy8ke3RyYWRlVHlwZX1gLCB7XG4gICAgICBjcnlwdG9fY3VycmVuY3k6IGNyeXB0b0N1cnJlbmN5LFxuICAgICAgYW1vdW50OiBhbW91bnQsXG4gICAgICBwaG9uZV9udW1iZXI6IHBob25lTnVtYmVyXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cblxuICBhc3luYyBnZXRUcmFkZUhpc3RvcnkobGltaXQgPSA1MCwgb2Zmc2V0ID0gMCk6IFByb21pc2U8e1xuICAgIHRyYWRlczogQXJyYXk8e1xuICAgICAgaWQ6IHN0cmluZztcbiAgICAgIHR5cGU6ICdidXknIHwgJ3NlbGwnO1xuICAgICAgY3J5cHRvX2N1cnJlbmN5OiBzdHJpbmc7XG4gICAgICBjcnlwdG9fYW1vdW50OiBudW1iZXI7XG4gICAgICBmaWF0X2Ftb3VudDogbnVtYmVyO1xuICAgICAgc3RhdHVzOiBzdHJpbmc7XG4gICAgICBjcmVhdGVkX2F0OiBzdHJpbmc7XG4gICAgICBjb21wbGV0ZWRfYXQ/OiBzdHJpbmc7XG4gICAgfT47XG4gICAgdG90YWw6IG51bWJlcjtcbiAgfT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy53YWxsZXRDbGllbnQuZ2V0KCcvYXBpL3RyYWRpbmcvaGlzdG9yeScsIHtcbiAgICAgIHBhcmFtczogeyBsaW1pdCwgb2Zmc2V0IH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYXBpQ2xpZW50ID0gbmV3IEFwaUNsaWVudCgpO1xuIl0sIm5hbWVzIjpbImF4aW9zIiwiY29va2llQXV0aCIsIkFwaUNsaWVudCIsInNldHVwSW50ZXJjZXB0b3JzIiwiYXV0aENsaWVudCIsImludGVyY2VwdG9ycyIsInJlcXVlc3QiLCJ1c2UiLCJjb25maWciLCJlcnJvciIsIlByb21pc2UiLCJyZWplY3QiLCJ3YWxsZXRDbGllbnQiLCJyZXNwb25zZSIsInN0YXR1cyIsInJlbW92ZUF1dGhDb29raWUiLCJsb2dpbiIsImNyZWRlbnRpYWxzIiwicG9zdCIsImRhdGEiLCJyZWdpc3RlciIsInVzZXJEYXRhIiwibWVzc2FnZSIsInVzZXIiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibG9nb3V0IiwiaXNBdXRoZW50aWNhdGVkIiwiZ2V0Q3VycmVudFVzZXIiLCJkZWNvZGVkVG9rZW4iLCJnZXREZWNvZGVkVG9rZW4iLCJpZCIsInVzZXJfaWQiLCJlbWFpbCIsImZpcnN0X25hbWUiLCJsYXN0X25hbWUiLCJyb2xlIiwiZ2V0VXNlckNvbmZpZyIsImdldCIsImdldERhc2hib2FyZFN1bW1hcnkiLCJnZXRXYWxsZXRCYWxhbmNlIiwiZ2V0VHJhbnNhY3Rpb25IaXN0b3J5IiwibGltaXQiLCJvZmZzZXQiLCJwYXJhbXMiLCJhZG1pbkxpc3RVc2VycyIsIm1hcHBlZCIsInEiLCJTdHJpbmciLCJ0b1VwcGVyQ2FzZSIsImFkbWluQ2xpZW50IiwiaXRlbXMiLCJBcnJheSIsImlzQXJyYXkiLCJwYWdlIiwicGFnZV9zaXplIiwibGVuZ3RoIiwidG90YWwiLCJzdWNjZXNzIiwicGFnaW5hdGlvbiIsImFkbWluR2V0VXNlciIsInVzZXJJZCIsImFkbWluVXBkYXRlVXNlciIsInBhdGNoIiwiYm9keSIsImRlZmF1bHRfY3VycmVuY3kiLCJjdXJyZW5jeSIsImdldFBvcnRmb2xpb1N1bW1hcnkiLCJnZXRSZXNlcnZlU3RhdHVzIiwicmVzZXJ2ZXMiLCJlbnRyeSIsImFjY3MiLCJhY2NvdW50cyIsInNpbXBsZUFjY3MiLCJtYXAiLCJhY2MiLCJpIiwiYWNjb3VudF90eXBlIiwidHlwZSIsImJhbGFuY2UiLCJ0b3RhbF9iYWxhbmNlIiwiYXZhaWxhYmxlX2JhbGFuY2UiLCJhdmFpbGFibGUiLCJsb2NrZWQiLCJsb2NrZWRfYmFsYW5jZSIsInB1c2giLCJwdXNoRnJvbUdyb3VwIiwiZ3JvdXAiLCJhY2NvdW50VHlwZSIsIk9iamVjdCIsImVudHJpZXMiLCJmb3JFYWNoIiwiaW5mbyIsIml0ZW0iLCJmaW5kIiwieCIsImNyeXB0byIsImZpYXQiLCJnZXRSZXNlcnZlQmFsYW5jZSIsImIiLCJudW1lcmljIiwiQm9vbGVhbiIsInRvcFVwUmVzZXJ2ZSIsImFtb3VudCIsInNvdXJjZV9yZWZlcmVuY2UiLCJ3aXRoZHJhd0Zyb21SZXNlcnZlIiwiZGVzdGluYXRpb25fcmVmZXJlbmNlIiwiZ2V0UmVzZXJ2ZUFuYWx5dGljcyIsInBlcmlvZF9kYXlzIiwiY2xlYXJSZXNlcnZlQ2FjaGUiLCJjYWxjdWxhdGVUcmFkZSIsInRyYWRlVHlwZSIsImNyeXB0b0N1cnJlbmN5IiwiY3J5cHRvX2N1cnJlbmN5IiwiZXhlY3V0ZVRyYWRlIiwicGhvbmVOdW1iZXIiLCJwaG9uZV9udW1iZXIiLCJnZXRUcmFkZUhpc3RvcnkiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsImJhc2VVUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwiLCJ3aXRoQ3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYXBpQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/api-client.ts\n"));

/***/ })

});